<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="../favicon.png">
    <link rel="apple-touch-icon" href="../apple-touch-icon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Module | Cable Factory ERP</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #f3f3f3;
            --fg: #000000;
            --gray-100: #f3f4f6;
            --gray-300: #d1d5db;
            --positive: #16a34a;
            --negative: #dc2626;
            --accent: #2563eb;
            --turquoise: #00b5ad;
        }
        body { font-family: 'IBM Plex Mono', monospace; background: var(--bg); color: var(--fg); font-size: 12px; line-height: 1.3; }
        .nav { position: sticky; top: 0; z-index: 50; border-bottom: 2px solid var(--fg); background: var(--bg); }
        .nav-container { max-width: 1400px; margin: 0 auto; padding: 0 64px; height: 56px; display: flex; align-items: center; }
        .nav-left { display: flex; align-items: center; gap: 12px; }
        .nav-logo { font-size: 18px; font-weight: 700; letter-spacing: 2px; text-decoration: none; color: var(--fg); }
        .nav-right { margin-left: auto; }
        .nav-link-small { color: var(--fg); text-decoration: underline; font-size: 11px; }
        .nav-divider { color: var(--fg); font-size: 14px; font-weight: 300; }
        .report { max-width: 1400px; margin: 0 auto; padding: 24px 64px; }
        .report h1 { font-size: 28px; margin-bottom: 8px; letter-spacing: 2px; }
        .report h2 { font-size: 18px; margin-top: 36px; margin-bottom: 12px; border-bottom: 2px solid #000; padding-bottom: 4px; scroll-margin-top: 72px; }
        .report h3 { font-size: 14px; margin-top: 20px; margin-bottom: 8px; }
        .report h4 { font-size: 12px; margin-top: 14px; margin-bottom: 6px; }
        .report p { font-size: 13px; line-height: 1.6; margin-bottom: 12px; }
        .report ul { font-size: 13px; margin: 12px 0; padding-left: 20px; }
        .report li { margin-bottom: 6px; line-height: 1.5; }
        .report ol { font-size: 13px; margin: 12px 0; padding-left: 20px; }
        .report ol li { margin-bottom: 6px; line-height: 1.5; }
        .report .subtitle { font-size: 14px; color: #666; margin-bottom: 4px; }
        .report .authors { font-size: 12px; color: #888; margin-bottom: 32px; }
        .report code { background: #e5e5e0; padding: 1px 5px; font-size: 12px; }
        .report pre { background: #1a1a2e; color: #e0e0e0; padding: 16px; margin: 12px 0; overflow-x: auto; font-size: 12px; line-height: 1.5; border: 2px solid #000; }
        .report pre .comment { color: #6a9955; }
        .report pre .keyword { color: #569cd6; }
        .report pre .string { color: #ce9178; }
        .report pre .decorator { color: #dcdcaa; }
        .report .abstract { background: #f5f5f0; padding: 16px; margin: 20px 0; border-left: 3px solid #000; }
        .report .finding { background: #fffbe6; padding: 12px; margin: 12px 0; border: 1px solid #e6d600; }
        .report .warning { background: #fee2e2; padding: 12px; margin: 12px 0; border: 1px solid #dc2626; }
        .report .discovery { background: #e6ffe6; padding: 12px; margin: 12px 0; border: 1px solid #0a0; }
        .report .insight { background: #eff6ff; padding: 12px; margin: 12px 0; border: 1px solid #2563eb; }
        .report .philosophy { background: #faf5ff; padding: 12px; margin: 12px 0; border: 1px solid #7c3aed; }
        .stat-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin: 16px 0; }
        .stat-grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin: 16px 0; }
        .stat-box { background: #f3f4f6; padding: 12px; text-align: center; border: 2px solid #000; }
        .stat-box .value { font-size: 24px; font-weight: bold; }
        .stat-box .label { font-size: 10px; color: #666; margin-top: 2px; }
        .report table { width: auto; border-collapse: collapse; border: 2px solid #000; margin: 16px 0; }
        .report tr:first-child { background: #f3f4f6; border-bottom: 2px solid #000; }
        .report th { padding: 4px 10px; text-align: left; font-size: 0.65rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.03em; white-space: nowrap; border-right: 2px solid #000; background: #f3f4f6; }
        .report th:last-child { border-right: none; }
        .report tr:not(:first-child) { border-bottom: 1px solid #d1d5db; }
        .report tr:last-child { border-bottom: none; }
        .report td { padding: 4px 10px; font-size: 0.75rem; border-right: 2px solid #000; }
        .report td:last-child { border-right: none; }
        .report tr:not(:first-child):hover { background: rgba(0,0,0,0.02); }
        .flow { display: flex; align-items: center; gap: 8px; margin: 16px 0; flex-wrap: wrap; }
        .flow-box { padding: 8px 14px; border: 2px solid #000; font-size: 12px; font-weight: 700; text-align: center; min-width: 100px; }
        .flow-arrow { font-size: 18px; font-weight: 700; }
        .flow-box.done { background: #dcfce7; border-color: #16a34a; }
        .flow-box.active { background: #dbeafe; border-color: #2563eb; }
        .flow-box.pending { background: #f3f4f6; }
        .arch-box { background: #fff; border: 2px solid #000; padding: 16px; margin: 12px 0; }
        .arch-box h4 { font-size: 14px; margin-bottom: 8px; margin-top: 0; }
        .arch-box p { font-size: 12px; line-height: 1.5; }
        .arch-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 16px; margin: 16px 0; }
        .back-link { display: inline-block; font-size: 12px; color: #666; text-decoration: none; margin-bottom: 24px; padding: 8px 0; }
        .back-link:hover { color: #000; }
        .back-link::before { content: "\2190  "; }
        .good { color: #16a34a; font-weight: 700; }
        .bad { color: #dc2626; font-weight: 700; }

        .submod-card { background: #fff; border: 2px solid #000; padding: 16px; margin: 10px 0; display: flex; align-items: flex-start; gap: 16px; }
        .submod-num { background: #000; color: #fff; font-size: 13px; font-weight: 700; min-width: 36px; height: 36px; padding: 0 8px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .submod-body { flex: 1; }
        .submod-body h4 { font-size: 14px; margin: 0 0 4px 0; }
        .submod-body p { font-size: 12px; color: #555; margin: 0 0 6px 0; line-height: 1.4; }
        .submod-tags { display: flex; gap: 6px; flex-wrap: wrap; }
        .submod-tag { font-size: 10px; padding: 2px 6px; background: #f3f4f6; border: 1px solid #d1d5db; }

        @media (max-width: 768px) {
            .report { padding: 16px; }
            .nav-container { padding: 0 16px; }
            .stat-grid, .stat-grid-3 { grid-template-columns: repeat(2, 1fr); }
            .flow { flex-direction: column; align-items: stretch; }
            .flow-arrow { transform: rotate(90deg); text-align: center; }
            .arch-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="nav-container">
            <div class="nav-left">
                <a href="erp-system.html" class="nav-logo">ERP SYSTEM</a>
            </div>
            <div class="nav-right">
                <a href="erp-mod-admin-tr.html" class="nav-link-small">TR</a>
                <span class="nav-divider">|</span>
                <a href="erp-mod-admin.html" class="nav-link-small" style="font-weight: 700;">EN</a>
            </div>
        </div>
    </nav>

    <main class="report">
        <a href="erp-deep-dives.html" class="back-link">Back to Modules</a>
        <h1>ADMIN &mdash; SYSTEM ADMINISTRATION</h1>
        <p class="subtitle">The control center of the entire ERP. User identities, permissions, authentication, printer hardware, print queue monitoring, AI assistant configuration, and activity auditing &mdash; everything that keeps the system secure, configured, and observable.</p>
        <p class="authors">February 2026 &bull; Solen Kablo &bull; Living Document</p>

        <div class="abstract">
            <p style="margin-bottom: 0;"><strong>Admin is the gatekeeper and the control room.</strong> Before any operator can scan a QR code, before any lab user can approve a test, before any engineer can design a cable &mdash; they must first exist as a user in this module with the right permissions. Admin defines <em>who</em> can access the system, <em>what</em> they can do once inside, <em>how</em> they authenticate, and <em>which hardware</em> the system can talk to. It manages a hybrid permission system that combines role-based access (super_admin, lab_user, operator) with ultra-granular page-and-button-level permissions stored as JSON. It controls the factory&rsquo;s label printers, monitors the print queue in real-time, and provides a full configuration interface for the AI assistant. Every action taken by every user is logged to an audit trail. Without this module, nobody can log in, no labels can print, and no permissions can be enforced.</p>
        </div>

        <div class="stat-grid">
            <div class="stat-box">
                <div class="value" style="color: var(--accent);">4</div>
                <div class="label">SUBMODULES</div>
            </div>
            <div class="stat-box">
                <div class="value" style="color: var(--turquoise);">~36</div>
                <div class="label">API ENDPOINTS</div>
            </div>
            <div class="stat-box">
                <div class="value">10</div>
                <div class="label">DATABASE TABLES</div>
            </div>
            <div class="stat-box">
                <div class="value" style="color: var(--positive);">3500+</div>
                <div class="label">LINES OF CODE</div>
            </div>
        </div>

        <!-- TABLE OF CONTENTS -->
        <div style="background: #fff; border: 2px solid #000; padding: 20px 28px; margin: 24px 0;">
            <h3 style="margin: 0 0 12px 0; font-size: 14px; letter-spacing: 1px;">TABLE OF CONTENTS</h3>
            <div style="columns: 2; column-gap: 32px; font-size: 12px; line-height: 2;">
                <a href="#sec-1" style="text-decoration: none; color: var(--fg); display: block;"><strong>1.</strong> What Admin Does</a>
                <a href="#sec-2" style="text-decoration: none; color: var(--fg); display: block;"><strong>2.</strong> The Data Flow</a>
                <a href="#sec-3" style="text-decoration: none; color: var(--fg); display: block;"><strong>3.</strong> The Database Layer</a>
                <a href="#sec-4" style="text-decoration: none; color: var(--fg); display: block;"><strong>4.</strong> The Backend Architecture</a>
                <a href="#sec-5" style="text-decoration: none; color: var(--fg); display: block;"><strong>5.</strong> The Frontend</a>
                <a href="#sec-6" style="text-decoration: none; color: var(--fg); display: block;"><strong>6.</strong> The Submodules</a>
                <a href="#sec-6-1" style="text-decoration: none; color: #555; display: block; padding-left: 16px;">6.1 Yaz&inodot;c&inodot; Y&ouml;netimi</a>
                <a href="#sec-6-2" style="text-decoration: none; color: #555; display: block; padding-left: 16px;">6.2 Yazd&inodot;rma &Idot;zleme</a>
                <a href="#sec-6-3" style="text-decoration: none; color: #555; display: block; padding-left: 16px;">6.3 AI Ayarlar&inodot;</a>
                <a href="#sec-6-4" style="text-decoration: none; color: #555; display: block; padding-left: 16px;">6.4 Kullan&inodot;c&inodot; Y&ouml;netimi</a>
                <a href="#sec-7" style="text-decoration: none; color: var(--fg); display: block;"><strong>7.</strong> Conclusion</a>
            </div>
        </div>

        <!-- ============================================ -->
        <h2 id="sec-1">1. WHAT ADMIN DOES</h2>
        <!-- ============================================ -->

        <p>The Admin module answers six questions that the entire ERP system depends on:</p>

        <table>
            <tr><th>Question</th><th>Who Answers It</th><th>How</th></tr>
            <tr><td>Who is allowed to use the system?</td><td>User Management</td><td>Create/edit/suspend/delete user accounts with role assignment</td></tr>
            <tr><td>What can each user do?</td><td>Permission System</td><td>Hybrid role-based + granular page.button JSON permissions</td></tr>
            <tr><td>How do users prove their identity?</td><td>Authentication</td><td>Username/password &rarr; JWT access + refresh tokens with session tracking</td></tr>
            <tr><td>Which printers exist and where?</td><td>Printer Management</td><td>Network printer registry with IP, port, material assignments, connection testing</td></tr>
            <tr><td>What&rsquo;s happening in the print queue?</td><td>Print Job Monitor</td><td>Real-time dashboard of all print jobs across 4 printers with retry/cancel</td></tr>
            <tr><td>How is the AI assistant configured?</td><td>AI Settings</td><td>Multi-provider API key management, model selection, audit logging</td></tr>
        </table>

        <h3>1.1 The Three User Types</h3>

        <p>The system recognizes three fundamental user types, each with a different scope of access and a different physical context of use:</p>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>Super Admin</h4>
                <p>Full system access. Can manage users, configure printers, adjust AI settings, view activity logs, and access every module. This is the factory manager or IT administrator. Typically operates from a desktop in the office.</p>
            </div>
            <div class="arch-box">
                <h4>Lab User</h4>
                <p>Lab dashboard, test management, quality control, alert management, and test reports. Can also test printer connections and retry failed print jobs. This is the quality engineer working in the laboratory. Typically operates from a dedicated lab workstation.</p>
            </div>
            <div class="arch-box">
                <h4>Operator</h4>
                <p>Machine operation, production forms, material scanning, basic dashboard, and work order viewing. This is the factory floor worker. Typically operates from a <strong>kiosk phone</strong> mounted near the production line &mdash; which is why operator accounts receive 6-month JWT tokens instead of the standard 12-hour expiry.</p>
            </div>
        </div>

        <h3>1.2 The Hybrid Permission Model</h3>

        <p>The permission system operates at two layers simultaneously:</p>

        <div class="finding">
            <p style="margin-bottom: 8px;"><strong>Layer 1 &mdash; Role-Based (Legacy):</strong> The <code>user_type</code> field on the user record. Checked by <code>is_permitted_user(user, ["super_admin", "lab_user"])</code>. This is the coarse filter: &ldquo;are you at least a lab user?&rdquo;</p>
            <p style="margin-bottom: 0;"><strong>Layer 2 &mdash; Granular (Modern):</strong> The <code>permissions</code> JSON field on the user record. Checked by <code>check_user_permission(user, page_id, button_id)</code>. This is the fine filter: &ldquo;on the Materials List page, can you click the Delete button?&rdquo;</p>
        </div>

        <p>Both layers coexist through a backward-compatible function called <code>check_permission_smart</code>. It first checks the legacy role-based system, then falls back to the granular JSON system. Super admins bypass both &mdash; they always pass.</p>

        <h3>1.3 Beyond User Management</h3>

        <p>Admin is not just about users. It is the only module that manages <strong>physical hardware</strong> (network printers on the factory floor), provides <strong>real-time operational monitoring</strong> (print queue dashboard), and controls the <strong>AI assistant</strong> that other users interact with. It is also the only module that writes to the <code>user_activity_logs</code> table, creating an audit trail of every administrative action taken in the system.</p>

        <!-- ============================================ -->
        <h2 id="sec-2">2. THE DATA FLOW</h2>
        <!-- ============================================ -->

        <p>Admin&rsquo;s data flows are fundamentally different from production modules like Hammadde or Teknik. Those modules have a linear pipeline (supplier &rarr; order &rarr; entry &rarr; inventory). Admin has a <strong>hub-and-spoke</strong> pattern: it sits at the center and every other module depends on it.</p>

        <h3>2.1 Authentication Flow</h3>

        <div class="flow">
            <div class="flow-box">User opens app</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box active">POST /auth/login</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box">bcrypt verify</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box done">JWT tokens issued</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box">Session recorded</div>
        </div>

        <p>Every subsequent API call across the <em>entire system</em> carries the JWT access token in the <code>Authorization: Bearer</code> header. The token contains the user&rsquo;s ID, username, user_type, and permissions &mdash; meaning every route in every module can verify identity and check permissions without an extra database query.</p>

        <h3>2.2 Permission Enforcement Flow</h3>

        <div class="flow">
            <div class="flow-box">API request arrives</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box">JWT decoded</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box active">check_permission_smart()</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box">Role check OR page.button check</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box done">Allow / 403 Forbidden</div>
        </div>

        <p>On the frontend, the same check runs proactively: routes are hidden from the menu, buttons are disabled or invisible, and entire pages redirect to the user&rsquo;s allowed dashboard if they attempt direct URL access.</p>

        <h3>2.3 Print Job Flow</h3>

        <div class="flow">
            <div class="flow-box">Material Entry / Materials List</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box active">POST /print-queue/queue/{id}</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box">Job &rarr; QUEUED</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box">Printer processes</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box done">COMPLETED / FAILED</div>
        </div>

        <p>Print jobs are created by other modules (Material Entry prints QR labels after recording a delivery, Materials List reprints labels on demand) but the queue itself lives in Admin. The Print Job Monitor gives super admins a real-time view of all jobs across all four factory printers, with the ability to retry failed jobs or cancel queued ones.</p>

        <h3>2.4 AI Interaction Flow</h3>

        <div class="flow">
            <div class="flow-box">User asks AI question</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box active">POST /api/ai/chat</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box">AI processes query</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box">Response returned</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box done">Audit log written</div>
        </div>

        <p>Every AI interaction is comprehensively logged: the user&rsquo;s query, detected language, AI model used, reasoning steps, tool calls, API responses, timing metrics, and security flags. This creates a complete forensic trail of what the AI did and why.</p>

        <h3>2.5 The Hub-and-Spoke Dependency</h3>

        <div class="insight">
            <p style="margin-bottom: 0;"><strong>Every module in the system is a spoke; Admin is the hub.</strong> Hammadde needs Admin for user authentication on every API call, for printer access when printing QR labels, and for permission checks on every button click. Teknik needs Admin for operator records and user identity. Production, Lab, Orders &mdash; all of them call <code>get_current_user_dependency</code> on every request, which decodes the JWT token that Admin issued. If Admin is down, the entire system is locked out.</p>
        </div>

        <!-- ============================================ -->
        <h2 id="sec-3">3. THE DATABASE LAYER</h2>
        <!-- ============================================ -->

        <p>The Admin module owns <strong>10 database tables</strong>, more than any other module. These tables fall into four groups: identity, sessions, hardware, and auditing.</p>

        <h3>3.1 Identity Tables</h3>

        <table>
            <tr><th>Table</th><th>Purpose</th><th>Key Columns</th><th>Relationships</th></tr>
            <tr>
                <td><code>users</code></td>
                <td>Core identity for every person in the system</td>
                <td>id, username (unique), email (unique), hashed_password, user_type, status, is_active, is_superuser, permissions (JSON text), force_password_change, last_login, preferred_interface, device_info</td>
                <td>1&mdash;N user_sessions, 0..1 super_admins, 0..1 lab_users, 0..1 operators</td>
            </tr>
            <tr>
                <td><code>super_admins</code></td>
                <td>Extension data for super admin users</td>
                <td>id, user_id (FK, unique), admin_level, permissions (JSON), access_logs (JSON)</td>
                <td>N&mdash;1 users</td>
            </tr>
            <tr>
                <td><code>lab_users</code></td>
                <td>Extension data for laboratory users</td>
                <td>id, user_id (FK, unique), lab_department, certifications (JSON), test_specializations (JSON), shift_schedule (JSON)</td>
                <td>N&mdash;1 users</td>
            </tr>
            <tr>
                <td><code>operators</code></td>
                <td>Extension data for factory floor operators</td>
                <td>id, user_id (FK, unique), assigned_machines (JSON), shift_schedule (JSON), skill_level, certifications (JSON)</td>
                <td>N&mdash;1 users</td>
            </tr>
            <tr>
                <td><code>user_roles</code></td>
                <td>Reusable permission templates</td>
                <td>id, name (unique), description, permissions (JSON text), is_system (prevents deletion)</td>
                <td>Standalone (template store)</td>
            </tr>
        </table>

        <div class="finding">
            <p style="margin-bottom: 0;"><strong>The Inheritance Pattern:</strong> Rather than using single-table inheritance with nullable columns, the system uses a <strong>joined-table pattern</strong>. The <code>users</code> table holds common fields (login credentials, status, permissions). The extension tables (<code>super_admins</code>, <code>lab_users</code>, <code>operators</code>) hold type-specific fields via a unique FK to <code>users.id</code>. This keeps the core <code>users</code> table lean while allowing each user type to store specialized data (e.g., operators have <code>assigned_machines</code>, lab users have <code>certifications</code>).</p>
        </div>

        <h3>3.2 Session Table</h3>

        <table>
            <tr><th>Table</th><th>Purpose</th><th>Key Columns</th><th>Relationships</th></tr>
            <tr>
                <td><code>user_sessions</code></td>
                <td>Active and historical login sessions</td>
                <td>id, user_id (FK), session_token (unique, indexed), refresh_token (unique, indexed), login_time, logout_time, expires_at, ip_address (IPv6-ready, 45 chars), user_agent, device_type, status</td>
                <td>N&mdash;1 users (cascade delete)</td>
            </tr>
        </table>

        <p>Sessions are not just for token validation. They provide a complete login history: which device was used, from which IP, when they logged in, when they logged out (or if the session expired). The cascade delete on the <code>users</code> relationship means deleting a user automatically purges all their sessions.</p>

        <h3>3.3 Hardware Tables</h3>

        <table>
            <tr><th>Table</th><th>Purpose</th><th>Key Columns</th><th>Relationships</th></tr>
            <tr>
                <td><code>printers</code></td>
                <td>Network label printers on the factory floor</td>
                <td>id, name, description, ip_address, port (default 9100), status (ONLINE/OFFLINE/ERROR/MAINTENANCE), is_active, assigned_materials (JSON array), location, last_checked</td>
                <td>Standalone</td>
            </tr>
            <tr>
                <td><code>print_jobs</code></td>
                <td>Label print job queue and history</td>
                <td>id, material_id (FK &rarr; raw_materials), qr_code, printer_id (1&ndash;4), copies, status (QUEUED/PRINTING/COMPLETED/FAILED/CANCELLED), retry_count, error_message, requested_by (FK &rarr; users), requested_at, started_at, completed_at, material_type, lot_number, supplier_name</td>
                <td>N&mdash;1 raw_materials, N&mdash;1 users</td>
            </tr>
        </table>

        <div class="finding">
            <p style="margin-bottom: 0;"><strong>Denormalized for display:</strong> The <code>print_jobs</code> table stores <code>material_type</code>, <code>lot_number</code>, and <code>supplier_name</code> as denormalized copies from the material record. This means the Print Job Monitor can display job history without joining to <code>raw_materials</code> or <code>suppliers</code> &mdash; critical for a real-time monitoring dashboard that refreshes frequently.</p>
        </div>

        <h3>3.4 Audit Tables</h3>

        <table>
            <tr><th>Table</th><th>Purpose</th><th>Key Columns</th><th>Relationships</th></tr>
            <tr>
                <td><code>user_activity_logs</code></td>
                <td>Audit trail of all admin actions</td>
                <td>id, user_id (FK, indexed), username (denormalized), action, module, target_type, target_id, details (JSON), ip_address, user_agent, created_at (indexed)</td>
                <td>N&mdash;1 users</td>
            </tr>
            <tr>
                <td><code>ai_audit_logs</code></td>
                <td>Comprehensive AI interaction forensics</td>
                <td>id, user_id, username, user_type, session_id, ip_address, device_type, browser, os, original_query, query_language, ai_model, ai_reasoning, ai_confidence, selected_tool, tool_params, api_endpoint, api_response_status, success, error_type, total_duration_ms, ai_processing_ms, security_flags, was_blocked, block_reason, created_at</td>
                <td>Standalone (47 columns)</td>
            </tr>
        </table>

        <div class="philosophy">
            <p style="margin-bottom: 0;"><strong>The AI audit table is the most wide table in the entire system</strong> &mdash; 47 columns. This is deliberate. Each AI interaction is a multi-step pipeline (query parsing &rarr; tool selection &rarr; API call &rarr; response generation) and every step produces data that may be needed for debugging or security review. The table has composite indexes on (user_id, created_at), (selected_tool, created_at), (success, created_at), and (ip_address, created_at) to support analytics queries without full table scans.</p>
        </div>

        <h3>3.5 Entity-Relationship Summary</h3>

        <table>
            <tr><th>Relationship</th><th>Type</th><th>Cascade</th></tr>
            <tr><td>users &rarr; user_sessions</td><td>1&mdash;N</td><td>Delete (user deletion purges sessions)</td></tr>
            <tr><td>users &rarr; super_admins</td><td>1&mdash;0..1</td><td>None (extension table)</td></tr>
            <tr><td>users &rarr; lab_users</td><td>1&mdash;0..1</td><td>None (extension table)</td></tr>
            <tr><td>users &rarr; operators</td><td>1&mdash;0..1</td><td>None (extension table)</td></tr>
            <tr><td>users &rarr; user_activity_logs</td><td>1&mdash;N</td><td>None (logs survive user deletion)</td></tr>
            <tr><td>users &rarr; print_jobs (requested_by)</td><td>1&mdash;N</td><td>None</td></tr>
            <tr><td>raw_materials &rarr; print_jobs (material_id)</td><td>1&mdash;N</td><td>None (cross-module FK)</td></tr>
        </table>

        <!-- ============================================ -->
        <h2 id="sec-4">4. THE BACKEND ARCHITECTURE</h2>
        <!-- ============================================ -->

        <p>The Admin backend is organized into five route groups, one core service, one security module, and a permission utility layer. Unlike production modules that have a single route file, Admin spans multiple files because its concerns are fundamentally different from each other.</p>

        <h3>4.1 Route Groups</h3>

        <table>
            <tr><th>Route Group</th><th>Prefix</th><th>Endpoints</th><th>Auth Required</th><th>Min. Role</th></tr>
            <tr><td>Authentication</td><td><code>/api/auth</code></td><td>5</td><td>Mixed (login is public)</td><td>None / Any</td></tr>
            <tr><td>User Management</td><td><code>/api/user-management</code></td><td>9</td><td>Yes</td><td>Super Admin (most), Any (operators list)</td></tr>
            <tr><td>Printers</td><td><code>/api/printers</code></td><td>5</td><td>Yes</td><td>Super Admin (CRUD), Lab User (test)</td></tr>
            <tr><td>Print Queue</td><td><code>/api/print-queue</code></td><td>5</td><td>Yes</td><td>Any (queue), Super Admin (manage)</td></tr>
            <tr><td>AI</td><td><code>/api/ai</code></td><td>12</td><td>Yes</td><td>Any (chat), Super Admin (config)</td></tr>
        </table>

        <h3>4.2 Authentication Endpoints (5)</h3>

        <table>
            <tr><th>Method</th><th>Path</th><th>Purpose</th><th>Key Behavior</th></tr>
            <tr><td>POST</td><td>/auth/login</td><td>User login</td><td>Accepts username/password + device_type + remember_me. Returns access_token, refresh_token, expires_in, user object. Creates session record.</td></tr>
            <tr><td>POST</td><td>/auth/logout</td><td>End session</td><td>Sets session status to &ldquo;terminated&rdquo;, stamps logout_time.</td></tr>
            <tr><td>POST</td><td>/auth/refresh</td><td>Renew access token</td><td>Validates refresh_token, generates new access_token. Does not rotate the refresh token.</td></tr>
            <tr><td>GET</td><td>/auth/me</td><td>Current user info</td><td>Decodes JWT, returns full user object with parsed permissions.</td></tr>
            <tr><td>GET</td><td>/auth/health</td><td>Health check</td><td>Returns status + database connectivity check.</td></tr>
        </table>

        <h3>4.3 User Management Endpoints (9)</h3>

        <table>
            <tr><th>Method</th><th>Path</th><th>Purpose</th><th>Key Behavior</th></tr>
            <tr><td>GET</td><td>/user-management/users/list</td><td>List all users</td><td>Supports status_filter and user_type query params. Parses permissions from JSON string to object.</td></tr>
            <tr><td>GET</td><td>/user-management/operators</td><td>List operators</td><td>Returns only active operators. Available to all authenticated users (needed by production modules).</td></tr>
            <tr><td>POST</td><td>/user-management/users/create</td><td>Create user</td><td>Auto-generates password if not provided. Sets force_password_change. Logs activity.</td></tr>
            <tr><td>PUT</td><td>/user-management/users/{id}</td><td>Update user</td><td>Partial update: username, email, full_name, user_type, status, is_active, permissions, password.</td></tr>
            <tr><td>POST</td><td>/user-management/users/{id}/suspend</td><td>Toggle suspend</td><td>Flips between &ldquo;active&rdquo; and &ldquo;suspended&rdquo; status. Logs activity.</td></tr>
            <tr><td>DELETE</td><td>/user-management/users/{id}</td><td>Delete user permanently</td><td>Hard delete. Prevents self-deletion (cannot delete your own account).</td></tr>
            <tr><td>POST</td><td>/user-management/users/{id}/reset-password</td><td>Force password reset</td><td>Generates secure 12-char random password (letters + digits + symbols). Sets force_password_change=True.</td></tr>
            <tr><td>GET</td><td>/user-management/roles/list</td><td>List role templates</td><td>Returns all UserRole records for use in permission template assignment.</td></tr>
            <tr><td>GET</td><td>/user-management/activity-logs</td><td>Activity log viewer</td><td>Supports filtering by user_id, module, action. Default limit 200.</td></tr>
        </table>

        <h3>4.4 Printer &amp; Print Queue Endpoints (10)</h3>

        <table>
            <tr><th>Method</th><th>Path</th><th>Purpose</th><th>Key Behavior</th></tr>
            <tr><td>GET</td><td>/printers/list</td><td>List printers</td><td>Optional active_only filter.</td></tr>
            <tr><td>POST</td><td>/printers/create</td><td>Add printer</td><td>Name, IP, port (default 9100), location, assigned_materials (JSON array).</td></tr>
            <tr><td>PUT</td><td>/printers/update/{id}</td><td>Edit printer</td><td>All fields updatable.</td></tr>
            <tr><td>POST</td><td>/printers/{id}/test</td><td>Test connection</td><td>Attempts network connection to printer IP:port. Updates status to ONLINE or OFFLINE.</td></tr>
            <tr><td>DELETE</td><td>/printers/{id}</td><td>Remove printer</td><td>Checks for pending print jobs before allowing deletion.</td></tr>
            <tr><td>POST</td><td>/print-queue/queue/{material_id}</td><td>Queue label print</td><td>Creates QUEUED job linked to material and requesting user. Printer selected by query param (1&ndash;4).</td></tr>
            <tr><td>GET</td><td>/print-queue/jobs</td><td>Job history</td><td>Filterable by status, printer_id. Max 500 results.</td></tr>
            <tr><td>POST</td><td>/print-queue/jobs/{id}/retry</td><td>Retry failed job</td><td>Resets status to QUEUED, increments retry_count.</td></tr>
            <tr><td>DELETE</td><td>/print-queue/jobs/{id}</td><td>Cancel job</td><td>Only QUEUED jobs can be cancelled (not PRINTING).</td></tr>
            <tr><td>GET</td><td>/print-queue/stats</td><td>Queue statistics</td><td>Returns counts: queued, printing, completed, failed.</td></tr>
        </table>

        <h3>4.5 AI Endpoints (12)</h3>

        <table>
            <tr><th>Method</th><th>Path</th><th>Purpose</th><th>Key Behavior</th></tr>
            <tr><td>POST</td><td>/api/ai/chat</td><td>Send AI query</td><td>Main chat endpoint. Processes query, calls tools, returns response.</td></tr>
            <tr><td>GET</td><td>/api/ai/status</td><td>Service status</td><td>Returns AI service health and configuration state.</td></tr>
            <tr><td>GET</td><td>/api/ai/models</td><td>Available models</td><td>Lists all supported AI models across providers.</td></tr>
            <tr><td>POST</td><td>/api/ai/reset</td><td>Reset AI agent</td><td>Clears conversation context and resets agent state.</td></tr>
            <tr><td>GET</td><td>/api/ai/config</td><td>Get configuration</td><td>Returns current: enabled flag, model_name, max_tokens, temperature.</td></tr>
            <tr><td>POST</td><td>/api/ai/config</td><td>Save configuration</td><td>Updates AI settings. Super admin only.</td></tr>
            <tr><td>GET</td><td>/api/ai/stats</td><td>Usage statistics</td><td>Query counts, success rates, average response times.</td></tr>
            <tr><td>GET</td><td>/api/ai/audit-logs</td><td>Audit log viewer</td><td>Paginated (limit + offset). Returns full interaction forensics.</td></tr>
            <tr><td>GET</td><td>/api/ai/api-keys/status</td><td>API key status</td><td>Returns masked key status for each provider (e.g., &ldquo;sk-***...abc&rdquo;).</td></tr>
            <tr><td>POST</td><td>/api/ai/api-keys/save</td><td>Store API key</td><td>Writes to .env file. Supports Gemini, OpenAI, Anthropic. Masks in response.</td></tr>
            <tr><td>DELETE</td><td>/api/ai/api-keys/{provider}</td><td>Remove API key</td><td>Removes key from .env file.</td></tr>
            <tr><td>POST</td><td>/api/ai/api-keys/test/{provider}</td><td>Test API key</td><td>Makes a lightweight API call to validate the key works.</td></tr>
        </table>

        <h3>4.6 Core Services</h3>

        <h4>AuthenticationService</h4>
        <p>The central authentication engine. Handles five operations:</p>
        <ul>
            <li><strong>authenticate_user</strong> &mdash; Finds user by username or email, verifies password with bcrypt, updates <code>last_login</code> timestamp.</li>
            <li><strong>create_user_session</strong> &mdash; Generates JWT access and refresh tokens. <em>Critical detail:</em> operator accounts get 6-month token expiry (for kiosk phones that shouldn&rsquo;t require re-login), while all other accounts get the standard 12-hour expiry.</li>
            <li><strong>get_user_by_token</strong> &mdash; Decodes JWT, validates expiry, checks that user still exists and is active.</li>
            <li><strong>logout_user</strong> &mdash; Terminates session record, stamps logout time.</li>
            <li><strong>refresh_token</strong> &mdash; Validates refresh token, issues new access token without creating a new session.</li>
        </ul>

        <h4>SecurityManager</h4>
        <p>Low-level cryptographic operations: bcrypt password hashing and verification, JWT creation with configurable expiry, JWT decoding with signature verification, and token expiry validation. Uses HS256 algorithm with a configurable secret key.</p>

        <h4>Permission Utilities</h4>
        <p>Four functions that form the permission checking backbone used by every module in the system:</p>
        <ul>
            <li><code>is_permitted_user(user, required_types)</code> &mdash; Legacy role check. Super admin always passes.</li>
            <li><code>check_user_permission(user, page_id, button_id)</code> &mdash; Granular JSON permission check. Parses the user&rsquo;s <code>permissions</code> field, navigates to <code>pages[page_id].buttons[button_id]</code>.</li>
            <li><code>has_special_permission(user, permission)</code> &mdash; Checks special flags like <code>hard_delete</code> or <code>manage_users</code>.</li>
            <li><code>check_permission_smart(user, required_types, page_id, button_id)</code> &mdash; The unified entry point. Tries role-based first, then granular. This is what most routes actually call.</li>
        </ul>

        <h3>4.7 FastAPI Dependencies</h3>

        <p>Admin defines four injectable dependencies that every module in the system imports:</p>

        <table>
            <tr><th>Dependency</th><th>What It Does</th><th>Used By</th></tr>
            <tr><td><code>get_current_user_dependency</code></td><td>Extracts and validates user from JWT token in Authorization header</td><td>Every authenticated endpoint in the system</td></tr>
            <tr><td><code>require_super_admin</code></td><td>Raises 403 unless user_type is &ldquo;super_admin&rdquo;</td><td>Admin CRUD operations, system configuration</td></tr>
            <tr><td><code>require_lab_user</code></td><td>Raises 403 unless user_type is &ldquo;lab_user&rdquo; or &ldquo;super_admin&rdquo;</td><td>Lab test routes, quality control</td></tr>
            <tr><td><code>require_operator</code></td><td>Raises 403 unless user_type is &ldquo;operator&rdquo; or above</td><td>Production routes, material scanning</td></tr>
        </table>

        <div class="insight">
            <p style="margin-bottom: 0;"><strong>Admin exports its security layer as importable dependencies.</strong> This is the architectural mechanism that makes Admin the hub: other modules don&rsquo;t implement their own authentication &mdash; they import <code>get_current_user_dependency</code> from Admin and use it as a FastAPI <code>Depends()</code> parameter. One source of truth, zero duplication.</p>
        </div>

        <!-- ============================================ -->
        <h2 id="sec-5">5. THE FRONTEND</h2>
        <!-- ============================================ -->

        <p>The Admin frontend consists of five distinct pages plus a cross-cutting permission layer that affects every page in the entire application.</p>

        <h3>5.1 Page Inventory</h3>

        <table>
            <tr><th>Page</th><th>Route</th><th>Component</th><th>Access</th></tr>
            <tr><td>Login</td><td>/user/login</td><td>src/pages/user/login/index.tsx</td><td>Public (unauthenticated)</td></tr>
            <tr><td>User Management</td><td>/admin/user-management</td><td>src/pages/Admin/UserManagement/index.tsx</td><td>canAdmin</td></tr>
            <tr><td>Printer Management</td><td>/admin/printer-management</td><td>src/pages/Admin/PrinterManagement/index.tsx</td><td>canAdmin</td></tr>
            <tr><td>Print Job Monitor</td><td>/admin/print-monitor</td><td>src/pages/Admin/PrintJobMonitor/index.tsx</td><td>canAdmin</td></tr>
            <tr><td>AI Settings</td><td>/admin/ai-settings</td><td>src/pages/Admin/AISettings/index.tsx</td><td>canAdmin</td></tr>
        </table>

        <p>All four admin pages sit under the <code>/admin</code> route prefix and share the <code>canAdmin</code> access guard, which restricts visibility to super admin users. The Login page is the only public page in the entire application.</p>

        <h3>5.2 The Permission Layer (Cross-Cutting)</h3>

        <p>Admin&rsquo;s most impactful frontend contribution isn&rsquo;t its own pages &mdash; it&rsquo;s the permission infrastructure that every other page uses. This lives in three files:</p>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>access.ts</h4>
                <p>Defines dynamic access functions: <code>canAdmin</code>, <code>canLab</code>, <code>canProduction</code>, etc. These are referenced in route config as access guards. Also provides <code>canAccessPage(pageId)</code> and module-level checks that read from the user&rsquo;s parsed permission JSON.</p>
            </div>
            <div class="arch-box">
                <h4>permissionManifest.ts</h4>
                <p>The static registry of every page and every button in the system. Defines page IDs (e.g., <code>admin.kullanici_yonetimi</code>), button IDs (e.g., <code>create_user</code>, <code>delete_user</code>), labels, descriptions, and <code>critical</code> flags. Used by User Management to render the permission editor.</p>
            </div>
            <div class="arch-box">
                <h4>buttonRegistry.ts</h4>
                <p>A dynamic counterpart to the static manifest. Components register their buttons at mount time into a global registry. This allows the User Management permission editor to discover buttons that exist in the running application, even if the manifest hasn&rsquo;t been updated.</p>
            </div>
        </div>

        <div class="finding">
            <p style="margin-bottom: 0;"><strong>The Hybrid Discovery Pattern:</strong> The permission system uses <em>both</em> a static manifest (hardcoded list of all pages and buttons) <em>and</em> a dynamic registry (components self-register at runtime). The User Management permission editor reads from the manifest for the structured tree view but can also discover dynamically registered buttons. This means new buttons added to any page in the system become available for permission assignment without manually updating a central config file.</p>
        </div>

        <h3>5.3 Login Page</h3>

        <p>The login page handles three scenarios:</p>
        <ol>
            <li><strong>Standard login:</strong> Username/password form with &ldquo;Remember me&rdquo; checkbox. Stores JWT tokens and user data in <code>localStorage</code> (<code>solen_auth_token</code>, <code>solen_refresh_token</code>, <code>solen_current_user</code>).</li>
            <li><strong>Kiosk auto-login:</strong> Detects the Fully Kiosk Browser via user agent string. When detected, automatically logs in as the operator account and redirects to <code>/production</code>. No human interaction required.</li>
            <li><strong>Secret URL token:</strong> Accepts <code>?kiosk=SOLEN_FACTORY_2024_KIOSK_SECRET</code> as a URL parameter to trigger auto-login from any browser. This is a factory-floor convenience for mounting new kiosk devices.</li>
        </ol>

        <h3>5.4 User Management Page</h3>

        <p>The most complex page in the Admin module. It provides a full CRUD interface for user accounts with a three-tab modal:</p>

        <ul>
            <li><strong>Tab 1 &mdash; Temel Bilgiler (Basic Info):</strong> Username, email, full name, user type (dropdown with super_admin, lab_user, operator, teknik_user, bakim_user, and custom types), status, password (for new users), force_password_change toggle.</li>
            <li><strong>Tab 2 &mdash; Yetkiler (Permissions):</strong> The granular permission editor. Renders the full permission manifest as a tree: each page is a switch (access on/off), and under each page, individual buttons are checkboxes. Includes four quick-fill templates: Full, Empty, Operator Default, Lab User Default.</li>
            <li><strong>Tab 3 &mdash; &Ouml;nizleme (Preview):</strong> Shows a read-only summary of what the user will be able to access after saving &mdash; which modules, which pages, which buttons.</li>
        </ul>

        <p>Beyond the modal, the page provides: search across username/email/full_name, filter by user_type and status, password reset (generates and displays new password), suspend/activate toggle, delete with confirmation, and last login display with Turkey/Istanbul timezone conversion.</p>

        <h3>5.5 Printer Management Page</h3>

        <p>CRUD interface for factory label printers. Each printer has: name, description, IP address, port, location, status, and assigned materials (multi-select from material types: raw_copper, raw_tin, raw_plastic, etc.). Includes a &ldquo;Test Connection&rdquo; button that hits the backend&rsquo;s <code>/printers/{id}/test</code> endpoint to verify the printer is reachable on the network.</p>

        <h3>5.6 Print Job Monitor Page</h3>

        <p>Real-time monitoring dashboard. Top section shows four statistics cards: Queued (blue), Printing (orange), Completed (green), Failed (red). Below is a ProTable showing all print jobs with columns: QR code, material type, lot number, supplier, printer, status, requested by, requested at, completed at, error message. Supports retry (requeues failed jobs) and cancel (removes queued jobs). All timestamps are Turkey/Istanbul timezone.</p>

        <h3>5.7 AI Settings Page</h3>

        <p>Four-tab configuration interface:</p>
        <ul>
            <li><strong>Overview:</strong> AI status (active/inactive), today&rsquo;s query count, total queries, average response time, success rate visualization, and a connection test button.</li>
            <li><strong>API Keys:</strong> Save, test, and delete API keys for three providers (Gemini, OpenAI, Anthropic). Keys are masked in the UI and stored in the server&rsquo;s .env file.</li>
            <li><strong>Model Settings:</strong> Enable/disable AI, select model (cascader grouped by provider: Gemini 3 Flash/Pro, GPT-5.2/Mini, Claude Sonnet/Opus/Haiku), configure max tokens (1024&ndash;8192) and temperature (0.1&ndash;0.9).</li>
            <li><strong>Audit Log:</strong> Full history of AI interactions. ProTable with expandable rows showing the original query and AI response. Filterable by user, tool, status, IP address. Includes response time metrics.</li>
        </ul>

        <h3>5.8 Common Frontend Patterns</h3>

        <table>
            <tr><th>Pattern</th><th>Usage</th></tr>
            <tr><td>ProTable (Ant Design Pro)</td><td>Every list page uses ProTable with built-in search, filtering, pagination, and toolbar customization.</td></tr>
            <tr><td>ProConfigProvider with trTR locale</td><td>All tables and forms display Turkish text for column headers, toolbar buttons, and empty states.</td></tr>
            <tr><td>PageContainer</td><td>Consistent page headers with breadcrumbs and title.</td></tr>
            <tr><td>Modal forms</td><td>Create/Edit operations use centered modals with form validation.</td></tr>
            <tr><td>Status Tags</td><td>Color-coded Ant Design Tags for status display (green=active, red=suspended, blue=queued, etc.).</td></tr>
            <tr><td>Turkey/Istanbul timezone</td><td>All timestamp displays convert to <code>Europe/Istanbul</code> using <code>toLocaleString()</code>.</td></tr>
            <tr><td>message.success / message.error</td><td>Ant Design notifications for operation feedback, all in Turkish.</td></tr>
        </table>

        <h3>5.9 The API Layer</h3>

        <p>The frontend communicates with the backend through a centralized API utility (<code>src/utils/api.ts</code>) that dynamically resolves the backend URL based on the deployment context:</p>

        <ul>
            <li><strong>HTTPS mode:</strong> Uses <code>/api</code> proxy (reverse proxy handles routing).</li>
            <li><strong>HTTP localhost:</strong> <code>http://localhost:8000/api</code> (development).</li>
            <li><strong>HTTP local network:</strong> <code>http://{hostname}:8000/api</code> (factory LAN access).</li>
            <li><strong>Custom override:</strong> <code>window.BACKEND_URL</code> for special deployments.</li>
        </ul>

        <p>Every API call includes the <code>Authorization: Bearer {token}</code> header, retrieved from <code>localStorage</code>. The authentication service (<code>src/services/realAuth.ts</code>) provides <code>login()</code>, <code>logout()</code>, <code>getCurrentUser()</code>, and <code>getToken()</code> functions that all pages import.</p>

        <!-- ============================================ -->
        <h2 id="sec-6">6. THE SUBMODULES</h2>
        <!-- ============================================ -->

        <p>The Admin module is organized into four submodules, ordered by operational flow: printers must be configured before print jobs can be monitored, AI settings stand alone, and user management governs access to everything.</p>

        <div class="submod-card">
            <div class="submod-num">6.1</div>
            <div class="submod-body">
                <h4>Yaz&inodot;c&inodot; Y&ouml;netimi (Printer Management)</h4>
                <p>Registry and configuration of network label printers on the factory floor. IP/port configuration, material type assignments, connection testing, and status monitoring.</p>
                <div class="submod-tags">
                    <span class="submod-tag">5 endpoints</span>
                    <span class="submod-tag">printers table</span>
                    <span class="submod-tag">TCP port 9100</span>
                    <span class="submod-tag">material assignments</span>
                </div>
            </div>
        </div>

        <div class="submod-card">
            <div class="submod-num">6.2</div>
            <div class="submod-body">
                <h4>Yazd&inodot;rma &Idot;zleme (Print Job Monitor)</h4>
                <p>Real-time dashboard monitoring all label print jobs across four printers. Queue statistics, job history, retry for failures, and cancel for queued jobs.</p>
                <div class="submod-tags">
                    <span class="submod-tag">5 endpoints</span>
                    <span class="submod-tag">print_jobs table</span>
                    <span class="submod-tag">real-time stats</span>
                    <span class="submod-tag">retry mechanism</span>
                </div>
            </div>
        </div>

        <div class="submod-card">
            <div class="submod-num">6.3</div>
            <div class="submod-body">
                <h4>AI Ayarlar&inodot; (AI Settings)</h4>
                <p>Configuration interface for the ERP&rsquo;s AI assistant. Multi-provider API key management, model selection, parameter tuning, usage statistics, and comprehensive audit logging of every AI interaction.</p>
                <div class="submod-tags">
                    <span class="submod-tag">12 endpoints</span>
                    <span class="submod-tag">ai_audit_logs (47 columns)</span>
                    <span class="submod-tag">3 AI providers</span>
                    <span class="submod-tag">.env key storage</span>
                </div>
            </div>
        </div>

        <div class="submod-card">
            <div class="submod-num">6.4</div>
            <div class="submod-body">
                <h4>Kullan&inodot;c&inodot; Y&ouml;netimi (User Management)</h4>
                <p>Full lifecycle management of user accounts: creation, editing, suspension, deletion, password reset, and the granular permission editor. Defines who exists in the system and what they can do.</p>
                <div class="submod-tags">
                    <span class="submod-tag">9 endpoints</span>
                    <span class="submod-tag">users + 3 extension tables</span>
                    <span class="submod-tag">user_roles templates</span>
                    <span class="submod-tag">activity_logs</span>
                    <span class="submod-tag">hybrid permission model</span>
                </div>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- 6.1  YAZICI YNETM                         -->
        <!-- ============================================ -->

        <h2 id="sec-6-1" style="margin-top: 48px;">6.1 Yaz&inodot;c&inodot; Y&ouml;netimi (Printer Management)</h2>

        <h3>6.1.1 Purpose and Business Context</h3>

        <p>Every raw material that enters the factory receives a printed A6 label with a QR code, weight, supplier, lot number, and entry date. These labels are the physical identity of the material &mdash; they&rsquo;re scanned at every downstream station (lab testing, production, stock). The label printers are industrial network devices (TCP port 9100 / IPP port 631) placed in specific locations: the laboratory and three production lines. <strong>Printer Management</strong> is the registry where these physical devices are configured, tested, and assigned to material types.</p>

        <p>Without this submodule, the system wouldn&rsquo;t know <em>where</em> to send print jobs. It answers four questions: What printers exist? Where are they? Are they online? What material types can each printer handle?</p>

        <h3>6.1.2 Database Schema</h3>

        <p>Single table: <code>printers</code> (model file: 66 lines)</p>

        <table>
            <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Purpose</th></tr>
            <tr><td><code>id</code></td><td>Integer PK</td><td>Auto-increment, indexed</td><td>Unique printer identifier</td></tr>
            <tr><td><code>name</code></td><td>String(100)</td><td>NOT NULL</td><td>Human-readable name (e.g. &ldquo;Lab Yaz&inodot;c&inodot;s&inodot;&rdquo;)</td></tr>
            <tr><td><code>description</code></td><td>Text</td><td>NULLABLE</td><td>Optional description</td></tr>
            <tr><td><code>ip_address</code></td><td>String(50)</td><td>NOT NULL</td><td>Network IP (e.g. 192.168.0.182)</td></tr>
            <tr><td><code>port</code></td><td>Integer</td><td>NOT NULL, default 9100</td><td>Network port (9100 for RAW, 631 for IPP)</td></tr>
            <tr><td><code>status</code></td><td>String(20)</td><td>NOT NULL, default &ldquo;online&rdquo;</td><td>Current status: online / offline / error / maintenance</td></tr>
            <tr><td><code>is_active</code></td><td>Boolean</td><td>NOT NULL, default True</td><td>Soft-enable/disable toggle</td></tr>
            <tr><td><code>assigned_materials</code></td><td>Text</td><td>NULLABLE</td><td>JSON array of material type codes this printer handles (e.g. <code>["raw_copper","raw_tin"]</code>)</td></tr>
            <tr><td><code>location</code></td><td>String(100)</td><td>NULLABLE</td><td>Physical location (e.g. &ldquo;Laboratuvar&rdquo;, &ldquo;&Uuml;retim - Hat 1&rdquo;)</td></tr>
            <tr><td><code>created_at</code></td><td>DateTime</td><td>NOT NULL, auto</td><td>Creation timestamp</td></tr>
            <tr><td><code>updated_at</code></td><td>DateTime</td><td>NOT NULL, auto + onupdate</td><td>Last modification timestamp</td></tr>
            <tr><td><code>last_checked</code></td><td>DateTime</td><td>NULLABLE</td><td>Last connection test timestamp</td></tr>
        </table>

        <h4>PrinterStatus Enum</h4>
        <pre><span class="keyword">class</span> <span class="string">PrinterStatus</span>(str, Enum):
    ONLINE      = <span class="string">"online"</span>
    OFFLINE     = <span class="string">"offline"</span>
    ERROR       = <span class="string">"error"</span>
    MAINTENANCE = <span class="string">"maintenance"</span></pre>

        <h4>Default Printers (Migration Seed Data)</h4>
        <table>
            <tr><th>ID</th><th>Name</th><th>IP</th><th>Port</th><th>Location</th><th>Assigned Materials</th></tr>
            <tr><td>1</td><td>Lab Yaz&inodot;c&inodot;s&inodot;</td><td>192.168.0.182</td><td>9100</td><td>Laboratuvar</td><td>A, B, C, D, E, F (all types)</td></tr>
            <tr><td>2</td><td>&Uuml;retim Yaz&inodot;c&inodot;s&inodot; 1</td><td>192.168.0.183</td><td>9100</td><td>&Uuml;retim - Hat 1</td><td>[] (none)</td></tr>
            <tr><td>3</td><td>&Uuml;retim Yaz&inodot;c&inodot;s&inodot; 2</td><td>192.168.0.184</td><td>9100</td><td>&Uuml;retim - Hat 2</td><td>[] (none)</td></tr>
            <tr><td>4</td><td>&Uuml;retim Yaz&inodot;c&inodot;s&inodot; 3</td><td>192.168.0.185</td><td>9100</td><td>&Uuml;retim - Hat 3</td><td>[] (none)</td></tr>
        </table>

        <h3>6.1.3 API Contract &mdash; 5 Endpoints</h3>

        <table>
            <tr><th>Method</th><th>Path</th><th>Permission</th><th>What It Does</th></tr>
            <tr><td><code>GET</code></td><td><code>/api/printers/list</code></td><td>Any authenticated</td><td>List all printers. Optional <code>?active_only=true</code> filter. Parses <code>assigned_materials</code> from JSON.</td></tr>
            <tr><td><code>POST</code></td><td><code>/api/printers/create</code></td><td>super_admin only</td><td>Create new printer. Required: name, ip_address. Default port=9100, status=online, is_active=true. Converts assigned_materials array to JSON string.</td></tr>
            <tr><td><code>PUT</code></td><td><code>/api/printers/update/{id}</code></td><td>super_admin only</td><td>Update printer. Partial update &mdash; only provided fields change. Stamps <code>updated_at</code>.</td></tr>
            <tr><td><code>POST</code></td><td><code>/api/printers/{id}/test</code></td><td>super_admin or lab_user</td><td>Test connection via CUPS <code>lpstat -p</code>. Updates <code>status</code> to online/offline and stamps <code>last_checked</code>.</td></tr>
            <tr><td><code>DELETE</code></td><td><code>/api/printers/{id}</code></td><td>super_admin only</td><td>Delete printer. <strong>Blocked</strong> if printer has pending jobs (QUEUED or PRINTING). Error: &ldquo;Bu yaz&inodot;c&inodot;n&inodot;n {n} bekleyen i&#351;i var.&rdquo;</td></tr>
        </table>

        <h3>6.1.4 CRUD Flow</h3>

        <p><strong>Create:</strong></p>
        <ol>
            <li>Click &ldquo;Yeni Yaz&inodot;c&inodot; Ekle&rdquo; button in toolbar</li>
            <li>Modal (600px) opens with 7 fields: name (required), description, location, IP address (required), port (default 9100), assigned materials (multi-select: A=Bak&inodot;r, B=Kalay, C=Plastik, D=Kataliz&ouml;r, E=Boya, F=Antirodent), status</li>
            <li>On submit: <code>POST /api/printers/create</code></li>
            <li>Backend creates record with <code>is_active=true</code>, <code>status=online</code>, converts assigned_materials array to JSON string</li>
            <li>On success: toast &ldquo;Yaz&inodot;c&inodot; &lsquo;{name}&rsquo; eklendi&rdquo; &rarr; modal closes &rarr; table reloads</li>
            <li><strong>Note:</strong> New printer requires application restart for its background print worker to initialize</li>
        </ol>

        <p><strong>Read:</strong></p>
        <ol>
            <li>Page loads &rarr; <code>GET /api/printers/list</code></li>
            <li>ProTable (11 columns) renders: ID, name, description, IP (blue tag), port, location, status (color-coded tag), assigned materials (letter tags), active (check/cross icon), actions</li>
            <li>Client-side search filters across name, description, IP, location, status, port, and ID simultaneously</li>
        </ol>

        <p><strong>Update:</strong></p>
        <ol>
            <li>Click edit icon in Actions column</li>
            <li>Same modal opens pre-filled with current values</li>
            <li>Modify any fields &rarr; click &ldquo;G&uuml;ncelle&rdquo;</li>
            <li><code>PUT /api/printers/update/{id}</code> &rarr; backend updates only provided fields, stamps <code>updated_at</code></li>
            <li>On success: toast &ldquo;Yaz&inodot;c&inodot; &lsquo;{name}&rsquo; g&uuml;ncellendi&rdquo; &rarr; modal closes &rarr; table reloads</li>
        </ol>

        <p><strong>Delete:</strong></p>
        <ol>
            <li>Click delete icon (danger button) in Actions column</li>
            <li>Confirmation modal: &ldquo;{name} yaz&inodot;c&inodot;s&inodot;n&inodot; silmek istedi&gbreve;inize emin misiniz?&rdquo;</li>
            <li>On confirm: <code>DELETE /api/printers/{id}</code></li>
            <li>Backend checks for pending print jobs (QUEUED or PRINTING status)</li>
            <li>If pending jobs exist: deletion <strong>blocked</strong> with error &ldquo;Bu yaz&inodot;c&inodot;n&inodot;n {n} bekleyen i&#351;i var. &Ouml;nce i&#351;leri tamamlay&inodot;n veya iptal edin.&rdquo;</li>
            <li>If no pending jobs: printer deleted &rarr; toast &rarr; table reloads</li>
        </ol>

        <p><strong>Test Connection:</strong></p>
        <ol>
            <li>Click test icon (ApiOutlined) in Actions column</li>
            <li><code>POST /api/printers/{id}/test</code></li>
            <li>Backend calls <code>PrintService.test_printer_connection()</code> which executes <code>lpstat -p {printer_name}</code> via subprocess</li>
            <li>Possible results: &ldquo;connected&rdquo; (idle), &ldquo;busy&rdquo;, &ldquo;not_found&rdquo;, &ldquo;timeout&rdquo;, &ldquo;error&rdquo;</li>
            <li>Backend updates <code>printer.status</code> (ONLINE or OFFLINE) and stamps <code>last_checked</code></li>
            <li>On success: toast with printer name &rarr; table reloads (status column reflects new state)</li>
            <li>On failure: warning message &rarr; table reloads (status shows &ldquo;&Ccedil;evrimd&inodot;&#351;&inodot;&rdquo; in red)</li>
        </ol>

        <h3>6.1.5 The Print Service &mdash; Label Generation Engine</h3>

        <p>File: <code>app/services/print_service.py</code> (576 lines). This is the core service that generates and prints A6 labels.</p>

        <h4>Label Specifications</h4>
        <table>
            <tr><th>Property</th><th>Value</th></tr>
            <tr><td>Size</td><td>A6 (827 &times; 1165 pixels)</td></tr>
            <tr><td>DPI</td><td>200</td></tr>
            <tr><td>QR Code Size</td><td>300px, centered, error correction level H</td></tr>
            <tr><td>Timezone</td><td>Europe/Istanbul (Turkey)</td></tr>
            <tr><td>Print Protocol</td><td>CUPS/IPP via <code>lp</code> command with A6 media + fit-to-page</td></tr>
            <tr><td>Timeout</td><td>10 seconds per print command</td></tr>
        </table>

        <h4>Label Content Layout</h4>
        <ol>
            <li>Centered QR code (300px) with QR text below</li>
            <li>Lot number (if exists)</li>
            <li>Weight (kg)</li>
            <li>Material type / product name</li>
            <li>Date and time (Turkey timezone)</li>
            <li>&ldquo;Created by&rdquo; user name</li>
            <li>Notes (if exists)</li>
        </ol>

        <h4>Key Service Methods</h4>
        <table>
            <tr><th>Method</th><th>What It Does</th></tr>
            <tr><td><code>generate_qr_code(data, size)</code></td><td>Creates QR code image with error correction H</td></tr>
            <tr><td><code>create_label_image(material_data)</code></td><td>Builds A6 label with QR, weight, supplier, lot, dates using PIL</td></tr>
            <tr><td><code>print_via_cups(image, printer_name, copies)</code></td><td>Saves to temp PNG &rarr; <code>lp</code> command with A6 media &rarr; cleans up</td></tr>
            <tr><td><code>print_label(material_data)</code></td><td>Generate + print single label (1 copy)</td></tr>
            <tr><td><code>print_label_with_quantity(material_data, copies)</code></td><td>Generate + print with multiple copies</td></tr>
            <tr><td><code>print_multiple_labels(materials)</code></td><td>Batch print: sequential processing with success/fail counts</td></tr>
            <tr><td><code>get_label_preview(material_data)</code></td><td>Returns base64-encoded label image (no printing)</td></tr>
            <tr><td><code>test_printer_connection(printer_name)</code></td><td>Runs <code>lpstat -p</code> subprocess, returns connected/busy/not_found/timeout/error</td></tr>
            <tr><td><code>get_available_printers()</code></td><td>Runs <code>lpstat -p -d</code>, parses available CUPS printers</td></tr>
        </table>

        <h4>Font Fallback Chain</h4>
        <p>The service tries fonts in platform order: macOS (<code>/System/Library/Fonts/</code>) &rarr; Linux (<code>/usr/share/fonts/</code>) &rarr; Windows (<code>C:/Windows/Fonts/</code>) &rarr; PIL default. This makes label generation work across all development and production environments.</p>

        <h3>6.1.6 The Print Worker &mdash; Background Job Processing</h3>

        <p>File: <code>app/services/print_worker.py</code> (292 lines). Each active printer gets a dedicated background worker thread.</p>

        <h4>Architecture</h4>
        <div class="flow">
            <span class="flow-step">App starts</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">initialize_workers(db_url)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Load active printers from DB</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Create PrintWorker per printer</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">start_all_workers()</span>
        </div>

        <h4>Worker Lifecycle</h4>
        <ol>
            <li><strong>Init:</strong> Generates CUPS printer name from IP (e.g. <code>Printer_192_168_0_182</code>), ensures printer is registered in CUPS via <code>lpadmin</code>, sets A6 as default media via <code>lpoptions</code></li>
            <li><strong>Poll loop:</strong> Every 1 second, queries DB for next QUEUED job for this printer (ordered by <code>requested_at</code> &mdash; FIFO)</li>
            <li><strong>Process job:</strong> Sets status to PRINTING &rarr; stamps <code>started_at</code> &rarr; fetches material + user data &rarr; calls <code>print_label_with_quantity()</code></li>
            <li><strong>On success:</strong> Status &rarr; COMPLETED, stamps <code>completed_at</code></li>
            <li><strong>On failure:</strong> If <code>retry_count &lt; 3</code>: increment, set back to QUEUED. If <code>retry_count &ge; 3</code>: status &rarr; FAILED</li>
        </ol>

        <h4>CUPS Auto-Registration</h4>
        <p>When a worker starts, if the printer isn&rsquo;t registered in CUPS, the worker automatically adds it:</p>
        <pre><span class="comment"># Auto-register printer in CUPS</span>
lpadmin -p Printer_192_168_0_182 -E -v ipp://192.168.0.182:631/ipp/print -m everywhere
lpoptions -p Printer_192_168_0_182 -o media=A6</pre>

        <h3>6.1.7 Material Assignment System</h3>

        <p>Each printer can be assigned specific material types via the <code>assigned_materials</code> JSON array. The six material type codes map to the factory&rsquo;s QR code letter system:</p>

        <table>
            <tr><th>Code</th><th>Letter</th><th>Material</th></tr>
            <tr><td><code>raw_copper</code></td><td>A</td><td>Bak&inodot;r (Copper)</td></tr>
            <tr><td><code>raw_tin</code></td><td>B</td><td>Kalay (Tin)</td></tr>
            <tr><td><code>raw_plastic</code></td><td>C</td><td>Plastik (Plastic)</td></tr>
            <tr><td><code>raw_catalyst</code></td><td>D</td><td>Kataliz&ouml;r (Catalyst)</td></tr>
            <tr><td><code>raw_dye</code></td><td>E</td><td>Boya (Dye)</td></tr>
            <tr><td><code>raw_antirodent</code></td><td>F</td><td>Antirodent</td></tr>
        </table>

        <p>The Lab printer (ID 1) is assigned all six types since it handles all material entries. Production printers have empty assignments &mdash; they are used for production-stage labeling.</p>

        <h3>6.1.8 Frontend Architecture</h3>

        <p>Single file: <code>src/pages/Admin/PrinterManagement/index.tsx</code> (527 lines). Route: <code>/admin/printer-management</code>.</p>

        <h4>Component Structure</h4>
        <div class="arch-grid">
            <div class="arch-box">
                <h4>ProTable (11 columns)</h4>
                <p>ID (fixed left), name (fixed left), description, IP address (blue tag), port, location, status (color-coded tag: green=online, red=offline, orange=error, gray=maintenance), assigned materials (letter tags), active (check/cross icon), actions (fixed right).</p>
            </div>
            <div class="arch-box">
                <h4>Add/Edit Modal (600px)</h4>
                <p>7 form fields: name (required), description (textarea), location, IP address (required), port (number, default 9100), assigned materials (multi-select with material codes), status (dropdown: online/offline/maintenance/error).</p>
            </div>
            <div class="arch-box">
                <h4>Toolbar</h4>
                <p>Search input (client-side filtering across all columns) + &ldquo;Yeni Yaz&inodot;c&inodot; Ekle&rdquo; primary button. Table options: density toggle, reload, column settings.</p>
            </div>
            <div class="arch-box">
                <h4>Action Buttons (per row)</h4>
                <p>Test connection (ApiOutlined), Edit (EditOutlined), Delete (DeleteOutlined, danger). Delete shows confirmation modal before proceeding.</p>
            </div>
        </div>

        <h4>Client-Side Search</h4>
        <p>The search input filters across <strong>all</strong> visible columns simultaneously: name, description, IP address, location, status (both English and Turkish terms), port, and ID. This is pure frontend filtering &mdash; the full dataset is always fetched.</p>

        <h4>No WebSocket Integration</h4>
        <p>Unlike other modules, Printer Management does not use WebSocket for real-time updates. Table refreshes happen via manual <code>actionRef.current?.reload()</code> after each mutation (create, update, delete, test).</p>

        <h3>6.1.9 Permission Model</h3>

        <p>Page ID: <code>admin.yazici_yonetimi</code></p>

        <table>
            <tr><th>Permission ID</th><th>Label</th><th>Description</th><th>Critical</th></tr>
            <tr><td><code>access_page</code></td><td>Sayfaya Eri&#351;im</td><td>View the page</td><td></td></tr>
            <tr><td><code>view_table</code></td><td>Tablo G&ouml;r&uuml;nt&uuml;le</td><td>See the printer table</td><td></td></tr>
            <tr><td><code>create_printer</code></td><td>Yeni Yaz&inodot;c&inodot; Ekle</td><td>Create a new printer</td><td></td></tr>
            <tr><td><code>edit_printer</code></td><td>Yaz&inodot;c&inodot; D&uuml;zenle</td><td>Update printer settings</td><td></td></tr>
            <tr><td><code>test_connection</code></td><td>Ba&gbreve;lant&inodot; Test</td><td>Test printer connectivity</td><td></td></tr>
            <tr><td><code>assign_materials</code></td><td>Malzeme Ata</td><td>Assign material types to printer</td><td></td></tr>
            <tr><td><code>delete_printer</code></td><td>Yaz&inodot;c&inodot; Sil</td><td>Delete a printer</td><td>&#9679;</td></tr>
        </table>

        <p>Backend enforces role-based: only <code>super_admin</code> can create/update/delete, <code>super_admin</code> + <code>lab_user</code> can test. Frontend registers these 7 granular permissions in <code>buttonRegistry</code> for the permission editor to discover.</p>

        <h3>6.1.10 How Printer Management Connects to the Rest of the System</h3>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>&rarr; Print Queue (6.2)</h4>
                <p>When Material Entry queues a print job, it specifies a <code>printer_id</code> (1&ndash;4). The print queue routes validate this ID against the printers table. The background workers are initialized from the printers table at application startup.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Material Entry (Hammadde Giri&#351;i)</h4>
                <p>After a material is entered, the success modal offers a &ldquo;Print Label&rdquo; button. This calls <code>POST /api/print-queue/queue/{material_id}?printer_id=X</code>, sending the job to the queue for the selected printer.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Materials List (Hammaddeler Listesi)</h4>
                <p>The reprint action in Materials List also targets a specific printer by ID. The <code>GET /api/materials/print/preview/{id}</code> endpoint uses <code>get_default_print_service()</code> which loads printer config from the printers table (prefers &ldquo;Lab&rdquo; printer, falls back to first active).</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Application Startup (main.py)</h4>
                <p><code>initialize_workers(db_url)</code> reads all active printers from DB, creates one <code>PrintWorker</code> daemon thread per printer, auto-registers each in CUPS, and starts polling. Workers are the bridge between the digital queue and physical hardware.</p>
            </div>
        </div>

        <div class="discovery">
            <p style="margin-bottom: 0;"><strong>Architecture insight:</strong> Printer Management is a hardware abstraction layer. The rest of the system never talks to printers directly &mdash; they queue jobs with a <code>printer_id</code>, and the worker threads handle the physical communication via CUPS/IPP. This decoupling means a printer can be replaced, re-IPed, or taken offline without any code changes in Material Entry or Materials List. The <code>assigned_materials</code> field is metadata for the UI (helping users pick the right printer) but is not enforced at the queue level &mdash; any printer can technically print any material&rsquo;s label.</p>
        </div>

        <!-- ============================================ -->
        <!-- 6.2  YAZDIRMA ZLEME                         -->
        <!-- ============================================ -->

        <h2 id="sec-6-2" style="margin-top: 48px;">6.2 Yazd&inodot;rma &Idot;zleme (Print Job Monitor)</h2>

        <h3>6.2.1 Purpose and Business Context</h3>

        <p>Every material label print passes through a job queue. The job is created the moment a user clicks &ldquo;Yazd&inodot;r&rdquo; in Material Entry or Materials List, and a background worker picks it up within one second. <strong>Yazd&inodot;rma &Idot;zleme</strong> is the real-time dashboard that makes this invisible pipeline visible: how many jobs are waiting, which are printing right now, which succeeded, which failed, and why.</p>

        <p>It serves two purposes: <strong>monitoring</strong> (are the printers keeping up? any failures?) and <strong>intervention</strong> (retry a failed job, cancel a queued one). Without this submodule, a failed print would silently vanish after 3 retries, and nobody would know a material is missing its label.</p>

        <h3>6.2.2 Database Schema</h3>

        <p>Single table: <code>print_jobs</code> (model file: 69 lines)</p>

        <table>
            <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Purpose</th></tr>
            <tr><td><code>id</code></td><td>Integer PK</td><td>Auto-increment, indexed</td><td>Unique job identifier</td></tr>
            <tr><td><code>material_id</code></td><td>Integer FK &rarr; raw_materials</td><td>NOT NULL</td><td>Which material this label is for</td></tr>
            <tr><td><code>qr_code</code></td><td>String(50)</td><td>NOT NULL</td><td>QR code text. Includes &ldquo; - REDDEDILDI&rdquo; suffix for rejected materials</td></tr>
            <tr><td><code>printer_id</code></td><td>Integer</td><td>NOT NULL, indexed</td><td>Target printer (1&ndash;4)</td></tr>
            <tr><td><code>copies</code></td><td>Integer</td><td>NOT NULL, default 1</td><td>Number of label copies to print</td></tr>
            <tr><td><code>status</code></td><td>String(20)</td><td>NOT NULL, indexed, default &ldquo;queued&rdquo;</td><td>Job lifecycle state</td></tr>
            <tr><td><code>retry_count</code></td><td>Integer</td><td>NOT NULL, default 0</td><td>How many times the worker retried (max 3)</td></tr>
            <tr><td><code>error_message</code></td><td>Text</td><td>NULLABLE</td><td>Error details if job failed</td></tr>
            <tr><td><code>requested_by</code></td><td>Integer FK &rarr; users</td><td>NOT NULL</td><td>User who triggered the print</td></tr>
            <tr><td><code>requested_at</code></td><td>DateTime</td><td>NOT NULL, auto</td><td>When the job was queued</td></tr>
            <tr><td><code>started_at</code></td><td>DateTime</td><td>NULLABLE</td><td>When the worker started printing</td></tr>
            <tr><td><code>completed_at</code></td><td>DateTime</td><td>NULLABLE</td><td>When the job completed or failed</td></tr>
            <tr><td><code>material_type</code></td><td>String(50)</td><td>NULLABLE, denormalized</td><td>Material type for fast display without join</td></tr>
            <tr><td><code>lot_number</code></td><td>String(100)</td><td>NULLABLE, denormalized</td><td>Lot number for fast display</td></tr>
            <tr><td><code>supplier_name</code></td><td>String(200)</td><td>NULLABLE, denormalized</td><td>Supplier name for fast display</td></tr>
        </table>

        <h4>PrintJobStatus Enum (5 states)</h4>
        <pre><span class="keyword">class</span> <span class="string">PrintJobStatus</span>(str, Enum):
    QUEUED    = <span class="string">"queued"</span>      <span class="comment"># Waiting in queue</span>
    PRINTING  = <span class="string">"printing"</span>    <span class="comment"># Worker is printing now</span>
    COMPLETED = <span class="string">"completed"</span>   <span class="comment"># Label printed successfully</span>
    FAILED    = <span class="string">"failed"</span>      <span class="comment"># Failed after 3 retries</span>
    CANCELLED = <span class="string">"cancelled"</span>   <span class="comment"># Manually cancelled by admin</span></pre>

        <h4>Job Lifecycle</h4>
        <div class="flow">
            <span class="flow-step">QUEUED</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">PRINTING</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">COMPLETED</span>
        </div>
        <div class="flow" style="margin-top: 8px;">
            <span class="flow-step">PRINTING (fail)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">QUEUED (retry &lt; 3)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">PRINTING</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">FAILED (retry &ge; 3)</span>
        </div>
        <div class="flow" style="margin-top: 8px;">
            <span class="flow-step">QUEUED</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">CANCELLED (manual)</span>
        </div>

        <h4>Denormalization Strategy</h4>
        <p>Three columns (<code>material_type</code>, <code>lot_number</code>, <code>supplier_name</code>) are deliberately denormalized from <code>raw_materials</code> and <code>suppliers</code>. This allows the monitoring dashboard to display all job data without expensive joins across tables &mdash; critical for a page that lists up to 500 jobs.</p>

        <h3>6.2.3 API Contract &mdash; 5 Endpoints</h3>

        <table>
            <tr><th>Method</th><th>Path</th><th>Permission</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/api/print-queue/queue/{material_id}?printer_id=X</code></td><td>super_admin, lab_user, operator</td><td>Queue a print job. Creates PrintJob with QUEUED status. Copies from <code>material.quantity</code> (default 1). Appends &ldquo; - REDDEDILDI&rdquo; to QR if material is rejected. Denormalizes material_type, lot_number, supplier_name.</td></tr>
            <tr><td><code>GET</code></td><td><code>/api/print-queue/jobs</code></td><td>super_admin only</td><td>List jobs with filters: <code>?status=</code>, <code>?printer_id=</code>, <code>?limit=</code> (default 100, max 500). Ordered by <code>requested_at DESC</code>. Calculates <code>duration</code> seconds if completed.</td></tr>
            <tr><td><code>POST</code></td><td><code>/api/print-queue/jobs/{id}/retry</code></td><td>super_admin or lab_user</td><td>Reset failed job: status &rarr; QUEUED, retry_count &rarr; 0, clears error_message, resets timestamps. Worker re-picks it.</td></tr>
            <tr><td><code>DELETE</code></td><td><code>/api/print-queue/jobs/{id}</code></td><td>super_admin only</td><td>Cancel a queued job. <strong>Blocked</strong> if status is PRINTING (&ldquo;Devam eden i&#351; iptal edilemez&rdquo;). Sets status &rarr; CANCELLED, stamps completed_at.</td></tr>
            <tr><td><code>GET</code></td><td><code>/api/print-queue/stats</code></td><td>super_admin only</td><td>Returns job counts: <code>{ queued, printing, completed, failed, total }</code>.</td></tr>
        </table>

        <h3>6.2.4 CRUD Flow</h3>

        <p><strong>Create (Queue a Print Job):</strong></p>
        <ol>
            <li>In Materials List, click the print icon on a material row (disabled for palettes/reels)</li>
            <li>Printer selection modal opens showing: QR code, label count (<code>material.quantity</code> or 1), and a dropdown of active printers fetched from <code>GET /api/printers/list?active_only=true</code></li>
            <li>Select printer &rarr; click &ldquo;Yazd&inodot;r&rdquo;</li>
            <li><code>POST /api/print-queue/queue/{material_id}?printer_id=X</code></li>
            <li>Backend validates material exists, gets supplier name from relationship, checks if material is rejected (appends &ldquo; - REDDEDILDI&rdquo; to QR), denormalizes type/lot/supplier into the job row</li>
            <li>On success: toast &ldquo;Yazd&inodot;rma i&#351;i kuyru&gbreve;a eklendi (#123)&rdquo; &rarr; modal closes</li>
            <li>Background worker picks up the job within 1 second and starts printing</li>
        </ol>

        <p><strong>Read (Monitor Jobs):</strong></p>
        <ol>
            <li>Navigate to /admin/print-monitor</li>
            <li>Page loads &rarr; <code>GET /api/print-queue/jobs?limit=200</code> + <code>GET /api/print-queue/stats</code></li>
            <li>4 stat cards render at the top: Bekleyen (gray), Yazd&inodot;r&inodot;l&inodot;yor (blue), Tamamlanan (green), Ba&#351;ar&inodot;s&inodot;z (red)</li>
            <li>ProTable (16 columns) renders all jobs with: ID, QR code (blue tag), material type (color-coded Turkish tag), lot, supplier, printer (filterable 1&ndash;4), copies (bold), status (color-coded tag), retry count (X/3 warning tag if &gt; 0), error message (red with tooltip), user, requested/started/completed timestamps (Turkey timezone), duration (seconds), actions</li>
            <li>Client-side search filters across QR code, lot, supplier, user, status, material type, ID, and printer &mdash; including Turkish translations</li>
        </ol>

        <p><strong>Retry (Failed &rarr; Queued):</strong></p>
        <ol>
            <li>Retry button (RedoOutlined) appears <strong>only</strong> on rows with status &ldquo;failed&rdquo;</li>
            <li>Click retry &rarr; <code>POST /api/print-queue/jobs/{id}/retry</code></li>
            <li>Backend resets: status &rarr; QUEUED, retry_count &rarr; 0, clears error_message, nulls started_at and completed_at</li>
            <li>On success: toast &ldquo;&#304;&#351; #{id} tekrar kuyru&gbreve;a eklendi&rdquo; &rarr; table + stats reload</li>
            <li>Worker re-picks the job on next poll cycle (within 1 second)</li>
        </ol>

        <p><strong>Cancel (Queued &rarr; Cancelled):</strong></p>
        <ol>
            <li>Cancel button (CloseCircleOutlined, danger) appears <strong>only</strong> on rows with status &ldquo;queued&rdquo;</li>
            <li>Click cancel &rarr; confirmation modal: &ldquo;&#304;&#351; #{id} iptal edilsin mi?&rdquo; with &ldquo;&#304;ptal Et&rdquo; (danger) / &ldquo;Vazge&ccedil;&rdquo;</li>
            <li>On confirm: <code>DELETE /api/print-queue/jobs/{id}</code></li>
            <li>Backend validates job is not PRINTING (blocks with &ldquo;Devam eden i&#351; iptal edilemez&rdquo;), sets status &rarr; CANCELLED, stamps completed_at</li>
            <li>On success: toast &ldquo;&#304;&#351; #{id} iptal edildi&rdquo; &rarr; table + stats reload</li>
        </ol>

        <h3>6.2.5 The Background Worker &mdash; How Jobs Actually Get Printed</h3>

        <p>The connection between this monitoring page and physical printing is the <code>PrintWorker</code> (292 lines, described in 6.1.6). Here&rsquo;s the exact data flow when a worker processes a job:</p>

        <div class="flow">
            <span class="flow-step">Poll DB every 1s</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Find oldest QUEUED job for this printer</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Status &rarr; PRINTING</span>
        </div>
        <div class="flow" style="margin-top: 8px;">
            <span class="flow-step">Fetch RawMaterial</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Fetch User (entered_by)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Build material_data dict</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">print_label_with_quantity()</span>
        </div>

        <h4>The material_data Dict (Built by Worker)</h4>
        <table>
            <tr><th>Key</th><th>Source</th></tr>
            <tr><td><code>qr_code</code></td><td><code>job.qr_code</code> (includes &ldquo;REDDEDILDI&rdquo; if rejected)</td></tr>
            <tr><td><code>material_type</code></td><td><code>job.material_type</code> (denormalized)</td></tr>
            <tr><td><code>lot_number</code></td><td><code>job.lot_number</code> or <code>material.lot_number</code></td></tr>
            <tr><td><code>supplier_name</code></td><td><code>job.supplier_name</code> (denormalized)</td></tr>
            <tr><td><code>weight</code></td><td><code>material.weight</code> (live from DB)</td></tr>
            <tr><td><code>received_date</code></td><td><code>material.received_date</code> (live from DB)</td></tr>
            <tr><td><code>entered_by</code></td><td><code>user.full_name</code> or <code>user.username</code> (live lookup)</td></tr>
            <tr><td><code>notes</code></td><td><code>material.notes</code> (live from DB)</td></tr>
        </table>

        <p>Note the hybrid approach: some fields come from the denormalized job row (fast, no join), while weight, date, user name, and notes are fetched live from DB (always current).</p>

        <h4>Retry Logic (Automatic)</h4>
        <table>
            <tr><th>retry_count</th><th>Print Fails</th><th>Result</th></tr>
            <tr><td>0</td><td>First attempt fails</td><td>retry_count &rarr; 1, status &rarr; QUEUED, error stored</td></tr>
            <tr><td>1</td><td>Second attempt fails</td><td>retry_count &rarr; 2, status &rarr; QUEUED</td></tr>
            <tr><td>2</td><td>Third attempt fails</td><td>retry_count &rarr; 3, status &rarr; QUEUED</td></tr>
            <tr><td>3</td><td>Fourth attempt fails</td><td>status &rarr; <strong>FAILED</strong>, completed_at stamped</td></tr>
        </table>

        <p>After the automatic 3 retries exhaust, the job shows as &ldquo;Ba&#351;ar&inodot;s&inodot;z&rdquo; with a retry count of &ldquo;3/3&rdquo; in the dashboard. An admin or lab user can then manually retry it (resetting the counter to 0).</p>

        <h3>6.2.6 Frontend Architecture</h3>

        <p>Single file: <code>src/pages/Admin/PrintJobMonitor/index.tsx</code> (509 lines). Route: <code>/admin/print-monitor</code>.</p>

        <h4>Component Structure</h4>
        <div class="arch-grid">
            <div class="arch-box">
                <h4>4 Stat Cards (Row, gutter 16)</h4>
                <p><strong>Bekleyen &#304;&#351;ler</strong> (gray #8c8c8c), <strong>Yazd&inodot;r&inodot;l&inodot;yor</strong> (blue #1890ff), <strong>Tamamlanan</strong> (green #52c41a), <strong>Ba&#351;ar&inodot;s&inodot;z</strong> (red #ff4d4f). Font size 24px. Refreshed after every table load and after retry/cancel actions.</p>
            </div>
            <div class="arch-box">
                <h4>ProTable (16 columns)</h4>
                <p>Default page size 50, max 500. Scroll width 1800px. Columns: ID (sortable, fixed left), QR code (blue tag), material type (color-coded), lot, supplier, printer (filterable), copies (bold), status (filterable, color-coded), retry count, error (red tooltip), user, 3 timestamps (Turkey TZ), duration, actions (fixed right).</p>
            </div>
            <div class="arch-box">
                <h4>Toolbar</h4>
                <p>Search input (client-side filtering across all columns including Turkish translations) + table options (density toggle, reload, column settings). Title: &ldquo;Yazd&inodot;rma &#304;&#351;leri&rdquo;.</p>
            </div>
            <div class="arch-box">
                <h4>Action Buttons (conditional)</h4>
                <p><strong>Retry</strong> (RedoOutlined): only visible on &ldquo;failed&rdquo; rows. <strong>Cancel</strong> (CloseCircleOutlined, danger): only visible on &ldquo;queued&rdquo; rows. No actions on &ldquo;printing&rdquo;, &ldquo;completed&rdquo;, or &ldquo;cancelled&rdquo; rows.</p>
            </div>
        </div>

        <h4>Date Formatting</h4>
        <p>All timestamps are stored as UTC in the database. The frontend converts them using <code>dayjs.utc(dateStr).tz('Europe/Istanbul')</code> and displays in <code>D.MM.YYYY HH:mm:ss</code> format (e.g. &ldquo;18.02.2026 14:30:45&rdquo;).</p>

        <h4>Material Type Tags (Color Mapping)</h4>
        <table>
            <tr><th>Type</th><th>Tag Color</th><th>Turkish Label</th></tr>
            <tr><td><code>raw_copper</code></td><td>orange</td><td>Bak&inodot;r</td></tr>
            <tr><td><code>raw_tin</code></td><td>cyan</td><td>Kalay</td></tr>
            <tr><td><code>raw_plastic</code></td><td>purple</td><td>Plastik</td></tr>
            <tr><td><code>raw_catalyst</code></td><td>magenta</td><td>Kataliz&ouml;r</td></tr>
            <tr><td><code>raw_dye</code></td><td>volcano</td><td>Boya</td></tr>
            <tr><td><code>raw_antirodent</code></td><td>geekblue</td><td>Antirodent</td></tr>
        </table>

        <h4>No WebSocket &mdash; Manual Refresh</h4>
        <p>Unlike other pages in the ERP, the Print Job Monitor does not use WebSocket for real-time updates. The table and stats refresh via <code>actionRef.current?.reload()</code> after mutations (retry, cancel) and on the table&rsquo;s built-in reload button. There is no automatic polling.</p>

        <h3>6.2.7 Permission Model</h3>

        <p>Page ID: <code>admin.yazdirma_izleme</code></p>

        <table>
            <tr><th>Permission ID</th><th>Label</th><th>Description</th></tr>
            <tr><td><code>access_page</code></td><td>Sayfaya Eri&#351;im</td><td>Yazd&inodot;rma izleme sayfas&inodot;n&inodot; g&ouml;r&uuml;nt&uuml;leme</td></tr>
            <tr><td><code>view_jobs</code></td><td>&#304;&#351;leri G&ouml;r&uuml;nt&uuml;le</td><td>Yazd&inodot;rma i&#351;lerini g&ouml;rme</td></tr>
            <tr><td><code>view_stats</code></td><td>&#304;statistikler</td><td>&#304;statistik kartlar&inodot;n&inodot; g&ouml;rme</td></tr>
            <tr><td><code>retry_job</code></td><td>Tekrar Dene</td><td>Ba&#351;ar&inodot;s&inodot;z i&#351;i tekrar &ccedil;al&inodot;&#351;t&inodot;rma</td></tr>
            <tr><td><code>cancel_job</code></td><td>&#304;&#351;i &#304;ptal Et</td><td>Bekleyen i&#351;i iptal etme</td></tr>
            <tr><td><code>refresh_data</code></td><td>Yenile</td><td>Veriyi yenileme butonu</td></tr>
        </table>

        <p>Backend enforces: <code>super_admin</code> can do everything. <code>lab_user</code> can retry failed jobs. <code>operator</code> can only queue new jobs (via Material Entry) but cannot access the monitoring dashboard.</p>

        <h3>6.2.8 How Print Job Monitor Connects to the Rest of the System</h3>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>&larr; Hammadde Giri&#351;i (Source)</h4>
                <p>After entering a material, the success modal&rsquo;s &ldquo;Yazd&inodot;r&rdquo; button queues a print job via <code>POST /print-queue/queue/{id}</code>. This is the primary job creation path.</p>
            </div>
            <div class="arch-box">
                <h4>&larr; Hammaddeler Listesi (Source)</h4>
                <p>The reprint button on any material row opens a printer selection modal (showing QR code + label count), then queues via the same endpoint. Disabled for palettes and reels.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Yaz&inodot;c&inodot; Y&ouml;netimi (6.1)</h4>
                <p>Print workers are initialized from the printers table. The printer selection modal in Materials List fetches active printers from <code>/api/printers/list</code>. Printer ID in the job maps to a physical device configured in 6.1.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; PrintWorker (Background)</h4>
                <p>One daemon thread per printer polls the print_jobs table every 1 second, processes QUEUED jobs in FIFO order, handles automatic retries (max 3), and updates job status. Described in detail in 6.1.6.</p>
            </div>
        </div>

        <div class="discovery">
            <p style="margin-bottom: 0;"><strong>Architecture insight:</strong> The print queue is a <em>non-blocking, fire-and-forget</em> system. When a user clicks &ldquo;Yazd&inodot;r&rdquo;, the API returns immediately with a job ID &mdash; the user doesn&rsquo;t wait for the physical printer. The worker processes it asynchronously. This design means Material Entry never blocks on slow or offline printers. The monitoring dashboard exists because this asynchrony creates an observability gap: you need a place to see what happened after you fired and forgot. The denormalization of material data into the job row is a deliberate performance trade-off &mdash; the monitoring page loads fast even with 500 jobs because it never joins to raw_materials or suppliers.</p>
        </div>

        <!-- ============================================ -->
        <!-- 6.3  AI AYARLARI                              -->
        <!-- ============================================ -->

        <h2 id="sec-6-3" style="margin-top: 48px;">6.3 AI Ayarlar&inodot; (AI Settings)</h2>

        <h3>6.3.1 Purpose and Business Context</h3>

        <p>The ERP includes an AI assistant currently powered by Google Gemini via API integration (with OpenAI and Anthropic Claude fully integrated and ready). The assistant can answer questions about orders, materials, production, and inventory by calling internal APIs on behalf of users. <strong>AI Ayarlar&inodot;</strong> is the configuration and monitoring center for this assistant: API key management, model selection, parameter tuning, usage statistics, and a comprehensive audit trail of every AI interaction.</p>

        <p>The current API-based integration is a <strong>fast-track demo layer</strong> &mdash; it provides immediate AI capabilities while the long-term vision develops in parallel. The roadmap is to build and deploy <strong>custom, locally-hosted models</strong> across the entire factory: production optimization, quality control, predictive maintenance, anomaly detection &mdash; essentially invisible AI agents that monitor and control everything constantly. For the language/search component specifically, a lightweight ~1B parameter model (such as Qwen or similar) will be fine-tuned for ERP-specific search query understanding, replacing the external API dependency entirely. The multi-provider architecture in this settings page was designed with this transition in mind &mdash; swapping from an external API to a local model endpoint is a configuration change, not a rewrite.</p>

        <p>The AI agent itself lives in a separate service (<code>solen_ai_service</code>), external to the main backend. This submodule provides the <em>control plane</em> &mdash; the knobs and dashboards that let an administrator manage the AI without touching code or config files.</p>

        <h3>6.3.2 Database Schema &mdash; The 47-Column Audit Log</h3>

        <p>The AI system uses two tables for forensic-grade audit logging:</p>

        <h4>ai_audit_logs (47 columns)</h4>
        <p>Every single AI interaction is recorded with full context. The columns are organized into 8 groups:</p>

        <table>
            <tr><th>Group</th><th>Columns</th><th>What It Captures</th></tr>
            <tr><td><strong>Identity</strong> (10)</td><td>user_id, username, user_type, session_id, session_token, ip_address, user_agent, device_type, browser, os</td><td>Who asked, from where, on what device</td></tr>
            <tr><td><strong>Query</strong> (6)</td><td>original_query, query_language, query_length, query_type, query_category, detected_entities</td><td>What was asked, classified and parsed (e.g. <code>{"order_id": 377}</code>)</td></tr>
            <tr><td><strong>AI Processing</strong> (9)</td><td>ai_model, ai_model_version, ai_preprocessing, ai_reasoning, ai_confidence, selected_tool, tool_params, tool_params_sanitized, alternative_tools</td><td>How the AI decided what to do, which tool it picked, what alternatives it considered</td></tr>
            <tr><td><strong>API Call</strong> (6)</td><td>api_endpoint, api_method, api_request_headers, api_response_status, api_response_data, api_response_size_bytes</td><td>The internal API call the AI made on behalf of the user</td></tr>
            <tr><td><strong>Result</strong> (6)</td><td>success, error_type, error_message, error_stack, final_response, response_type</td><td>What the AI answered, whether it succeeded, error details if not</td></tr>
            <tr><td><strong>Performance</strong> (4)</td><td>total_duration_ms, ai_processing_ms, api_call_ms, response_generation_ms</td><td>Timing breakdown: AI thinking + API call + response generation</td></tr>
            <tr><td><strong>Security</strong> (4)</td><td>security_flags, rate_limit_status, was_blocked, block_reason</td><td>Injection detection, rate limiting, blocked queries</td></tr>
            <tr><td><strong>Meta</strong> (2)</td><td>created_at, metadata</td><td>Timestamp and extensible JSON metadata</td></tr>
        </table>

        <p>11 indexes optimize queries: single-column on user_id, username, session_id, ip_address, selected_tool, success, created_at; composite on (user_id, created_at), (selected_tool, created_at), (success, created_at), (ip_address, created_at).</p>

        <h4>ai_audit_log_summaries (12 columns)</h4>
        <p>Daily aggregated statistics: total/successful/failed/blocked queries, unique users and IPs, top tools, top categories, average response times, error distribution. One row per day. Not currently exposed via API &mdash; reserved for future analytics dashboards.</p>

        <h3>6.3.3 API Contract &mdash; 12 Endpoints</h3>

        <table>
            <tr><th>Method</th><th>Path</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/api/ai/chat</code></td><td>Send a query to the AI agent. Checks if AI is enabled. Returns response, tools used, timing. Sanitizes errors for users.</td></tr>
            <tr><td><code>GET</code></td><td><code>/api/ai/status</code></td><td>Check AI readiness: API key configured, model name, agent status (ready/error/not_initialized).</td></tr>
            <tr><td><code>GET</code></td><td><code>/api/ai/models</code></td><td>List available models grouped by provider with tier, description, recommended flag, coming_soon flag.</td></tr>
            <tr><td><code>POST</code></td><td><code>/api/ai/reset</code></td><td>Destroy current agent singleton. Reinitializes on next request with latest config.</td></tr>
            <tr><td><code>GET</code></td><td><code>/api/ai/config</code></td><td>Get current config: enabled, model_name, max_tokens, temperature, key status.</td></tr>
            <tr><td><code>POST</code></td><td><code>/api/ai/config</code></td><td>Update config. Partial updates supported. Saves to <code>ai_config.json</code>.</td></tr>
            <tr><td><code>GET</code></td><td><code>/api/ai/stats</code></td><td>Usage statistics from audit table: total/successful/failed queries, avg response time, today&rsquo;s count.</td></tr>
            <tr><td><code>GET</code></td><td><code>/api/ai/audit-logs</code></td><td>Paginated audit log entries. Params: <code>?limit=100&amp;offset=0</code>. Returns key fields for display.</td></tr>
            <tr><td><code>GET</code></td><td><code>/api/ai/api-keys/status</code></td><td>Status of all 3 provider keys: configured flag + masked preview (first 8 + &ldquo;...&rdquo; + last 4 chars).</td></tr>
            <tr><td><code>POST</code></td><td><code>/api/ai/api-keys/save</code></td><td>Save API key for a provider. Validates length (&ge; 20), checks prefix (warning only). Writes to <code>.env</code>, updates runtime env, resets agent.</td></tr>
            <tr><td><code>DELETE</code></td><td><code>/api/ai/api-keys/{provider}</code></td><td>Remove API key from <code>.env</code> and runtime environment.</td></tr>
            <tr><td><code>POST</code></td><td><code>/api/ai/api-keys/test/{provider}</code></td><td>Test key validity: Gemini via client instantiation, OpenAI/Anthropic via models endpoint.</td></tr>
        </table>

        <h3>6.3.4 CRUD Flow</h3>

        <p><strong>Create / Update API Key:</strong></p>
        <ol>
            <li>Navigate to &ldquo;API Anahtarlar&inodot;&rdquo; tab &rarr; 3 provider cards (Google Gemini, OpenAI, Anthropic Claude) each with logo, status tag, and password input</li>
            <li>Enter API key in the password field &rarr; click &ldquo;Kaydet&rdquo;</li>
            <li><code>POST /api/ai/api-keys/save</code> with <code>{ provider, api_key }</code></li>
            <li>Backend validates: not empty, &ge; 20 chars, checks prefix (AIza for Gemini, sk- for OpenAI, sk-ant- for Anthropic &mdash; warning only, not blocking)</li>
            <li>Writes to <code>solen_ai_service/.env</code> file, updates runtime <code>os.environ</code>, resets AI agent singleton</li>
            <li>On success: toast &ldquo;API anahtar&inodot; kaydedildi&rdquo; + prefix warning if applicable &rarr; masked key shown on card &rarr; status refreshes</li>
        </ol>

        <p><strong>Read (Overview Dashboard):</strong></p>
        <ol>
            <li>Navigate to /admin/ai-settings &rarr; &ldquo;Genel Bak&inodot;&#351;&rdquo; tab loads</li>
            <li>4 stat cards: AI status (active/inactive), today&rsquo;s queries, total queries, average response time</li>
            <li>Success rate card with circular progress chart + successful/failed counts</li>
            <li>Connection test card: shows status, API key status, current model. &ldquo;Ba&gbreve;lant&inodot;y&inodot; Test Et&rdquo; button calls <code>GET /api/ai/status</code></li>
        </ol>

        <p><strong>Update Model Settings:</strong></p>
        <ol>
            <li>Navigate to &ldquo;Model Ayarlar&inodot;&rdquo; tab</li>
            <li>Form with 4 fields: AI enabled (switch), model (cascader: Provider &rarr; Model, with tier tags and recommended stars), max tokens (select: 1024/2048/4096/8192), temperature (select: 0.1/0.3/0.5/0.7/0.9)</li>
            <li>Click &ldquo;Ayarlar&inodot; Kaydet&rdquo;</li>
            <li><code>POST /api/ai/config</code> &rarr; saves to <code>ai_config.json</code></li>
            <li><code>POST /api/ai/reset</code> &rarr; destroys current agent, reinitializes with new config on next query</li>
            <li>Toast: &ldquo;Ayarlar kaydedildi - AI yeniden ba&#351;lat&inodot;ld&inodot;&rdquo;</li>
        </ol>

        <p><strong>Delete API Key:</strong></p>
        <ol>
            <li>Click &ldquo;Sil&rdquo; button on a provider card</li>
            <li>Confirmation modal</li>
            <li><code>DELETE /api/ai/api-keys/{provider}</code></li>
            <li>Backend removes key from <code>.env</code> file and <code>os.environ</code></li>
            <li>Toast: &ldquo;API anahtar&inodot; silindi&rdquo; &rarr; card reverts to unconfigured state</li>
        </ol>

        <p><strong>Test API Key:</strong></p>
        <ol>
            <li>Click &ldquo;Test Et&rdquo; button on a configured provider card</li>
            <li><code>POST /api/ai/api-keys/test/{provider}</code></li>
            <li>Backend tests: Gemini via client instantiation, OpenAI via <code>GET https://api.openai.com/v1/models</code>, Anthropic via <code>GET https://api.anthropic.com/v1/models</code></li>
            <li>Success toast or error toast with details</li>
        </ol>

        <h3>6.3.5 AI Provider Configuration</h3>

        <table>
            <tr><th>Provider</th><th>Env Variable</th><th>Key Prefix</th><th>Models</th><th>Status</th></tr>
            <tr><td><strong>Google Gemini</strong></td><td><code>GEMINI_API_KEY</code></td><td><code>AIza</code></td><td>gemini-3-flash (recommended), gemini-3-pro, gemini-2.5-flash, gemini-2.5-pro</td><td>Active</td></tr>
            <tr><td><strong>OpenAI</strong></td><td><code>OPENAI_API_KEY</code></td><td><code>sk-</code></td><td>gpt-5.2 (recommended), gpt-5-mini, o3, gpt-4.1</td><td>Active</td></tr>
            <tr><td><strong>Anthropic Claude</strong></td><td><code>ANTHROPIC_API_KEY</code></td><td><code>sk-ant-</code></td><td>claude-sonnet-4-5 (recommended), claude-opus-4-5, claude-haiku-4-5</td><td>Active</td></tr>
        </table>

        <h4>Key Storage Architecture</h4>
        <p>API keys are stored in a <code>.env</code> file inside the <code>solen_ai_service</code> directory (separate from the main backend). They are <strong>never</strong> stored in the database. On save, the key is also set in <code>os.environ</code> for immediate use without restart. Keys are <strong>never</strong> returned in API responses &mdash; only masked previews (first 8 + &ldquo;...&rdquo; + last 4 characters).</p>

        <h4>Configuration Storage</h4>
        <p>Model settings (enabled, model_name, max_tokens, temperature) are stored in <code>ai_config.json</code> alongside the <code>.env</code> file. Defaults: enabled=true, model=gemini-3-flash, max_tokens=4096, temperature=0.7.</p>

        <h3>6.3.6 The AI Agent &mdash; Singleton Architecture</h3>

        <p>The AI agent (<code>SolenAIAgent</code>) is a singleton that persists across requests. It&rsquo;s initialized on the first AI query and reused until explicitly reset.</p>

        <div class="flow">
            <span class="flow-step">First /ai/chat call</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Load ai_config.json</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Create SolenAIAgent(config)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Singleton stored in _agent_instance</span>
        </div>

        <p>The agent is reset (destroyed and recreated) when: API keys are saved/deleted, config is updated via the settings page, or <code>POST /api/ai/reset</code> is called. This ensures the agent always uses the latest configuration.</p>

        <h4>Chat Request Flow</h4>
        <ol>
            <li>User sends query via <code>POST /api/ai/chat</code> with <code>{ query, conversation_history, user_type }</code></li>
            <li>Backend checks <code>ai_config.json</code> &mdash; if <code>enabled: false</code>, returns &ldquo;AI servisi &#351;u an devre d&inodot;&#351;&inodot;&rdquo;</li>
            <li>Gets or creates agent singleton, extracts user info from JWT</li>
            <li>Calls <code>agent.process_query(query, history, user_type, ip, username, user_id)</code></li>
            <li>Agent internally: preprocesses query, selects tool, calls internal API, generates response, <strong>writes audit log</strong></li>
            <li>Backend sanitizes response (hides raw API errors), returns <code>{ success, response, tool_used, timing_ms }</code></li>
        </ol>

        <h3>6.3.7 Audit Logging &mdash; Forensic-Grade Tracking</h3>

        <p>Every AI interaction writes a row to <code>ai_audit_logs</code> with 47 columns of context. The audit log answers 7 questions about every query:</p>

        <ol>
            <li><strong>Who?</strong> &mdash; user_id, username, user_type, session info, IP, device, browser, OS</li>
            <li><strong>What?</strong> &mdash; original query, language, type (search/question/command), category (order/material/production), detected entities</li>
            <li><strong>How?</strong> &mdash; AI model, reasoning, confidence score, selected tool, tool parameters, alternative tools considered</li>
            <li><strong>Where?</strong> &mdash; API endpoint called, method, response status, response data, response size</li>
            <li><strong>Result?</strong> &mdash; success/fail, error type and message, final response text, response type</li>
            <li><strong>Performance?</strong> &mdash; total ms, AI processing ms, API call ms, response generation ms</li>
            <li><strong>Security?</strong> &mdash; injection flags, rate limit status, blocked flag and reason</li>
        </ol>

        <h3>6.3.8 Frontend Architecture</h3>

        <p>Single file: <code>src/pages/Admin/AISettings/index.tsx</code> (1,177 lines). Route: <code>/admin/ai-settings</code>.</p>

        <h4>4-Tab Layout</h4>
        <div class="arch-grid">
            <div class="arch-box">
                <h4>Tab 1: Genel Bak&inodot;&#351; (Overview)</h4>
                <p>4 stat cards (AI status, today&rsquo;s queries, total queries, avg response time). Success rate circular progress chart. Connection test card with status indicator, API key flag, and model name.</p>
            </div>
            <div class="arch-box">
                <h4>Tab 2: API Anahtarlar&inodot; (API Keys)</h4>
                <p>3 provider cards (Gemini, OpenAI, Claude) each with: provider logo, &ldquo;Aktif&rdquo; status tag, masked key display, password input, save/test/delete buttons, and link to provider&rsquo;s API console. Plus AI service account status card.</p>
            </div>
            <div class="arch-box">
                <h4>Tab 3: Model Ayarlar&inodot; (Model Settings)</h4>
                <p>Form: enabled switch, model cascader (Provider &rarr; Model with icons, tier tags, recommended stars, disabled if no API key), max tokens select (1024&ndash;8192), temperature select (0.1&ndash;0.9). Save triggers config update + agent reset.</p>
            </div>
            <div class="arch-box">
                <h4>Tab 4: Kullan&inodot;m Ge&ccedil;mi&#351;i (Audit Log)</h4>
                <p>ProTable with expandable rows. Columns: timestamp, username + user_type tag, tool used (blue tag), status (success/error), response time (color-coded: green &lt; 500ms, orange 500&ndash;1000ms, red &gt; 1000ms), IP. Expanded row shows: query, AI response, error message. Search, pagination (10/20/50), density controls.</p>
            </div>
        </div>

        <h3>6.3.9 Permission Model</h3>

        <p>AI Settings does not have granular button-level permissions in the manifest. Access is controlled at the module level via <code>canAdmin</code> &mdash; any user with access to the admin module can view AI Settings. Backend endpoints have no explicit permission checks beyond JWT authentication.</p>

        <p>This is a deliberate design choice: AI configuration is considered an admin-wide capability, not a per-button permission. In practice, only super admins access the admin module.</p>

        <h3>6.3.10 How AI Settings Connects to the Rest of the System</h3>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>&rarr; AI Agent (External Service)</h4>
                <p>The settings page configures the external <code>solen_ai_service</code> which contains the <code>SolenAIAgent</code>. API keys, model selection, and parameters are stored in files that the agent reads. The agent is imported as a singleton into the backend.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; AI Search (Query Preprocessing)</h4>
                <p><code>ai_search_service.py</code> (256 lines) uses Gemini to preprocess search queries: Turkish character correction, query classification, entity detection. Falls back to rule-based processing if AI is unavailable.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; All ERP Modules (via AI Chat)</h4>
                <p>The AI agent can call internal APIs on behalf of users &mdash; querying orders, materials, suppliers, production data. It&rsquo;s a read-only assistant that <em>consumes</em> data from every module but never writes.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Audit &amp; Compliance</h4>
                <p>The 47-column audit log creates a complete forensic trail of every AI interaction: who asked what, how the AI processed it, what API it called, what it answered, and how long it took. This supports both debugging and security auditing.</p>
            </div>
        </div>

        <div class="discovery">
            <p style="margin-bottom: 0;"><strong>Architecture insight:</strong> The AI system follows a <em>control plane / data plane</em> separation. The control plane (this settings page) manages configuration, keys, and monitoring. The data plane (the external <code>SolenAIAgent</code>) handles actual query processing. This separation means the AI agent can be upgraded, swapped, or scaled independently of the ERP backend. The 47-column audit log is deliberately over-engineered &mdash; it captures far more context than needed for basic logging, because AI forensics requires understanding not just <em>what</em> the AI did, but <em>why</em> it chose that action and what alternatives it considered. The multi-provider architecture (all 3 providers &mdash; Gemini, OpenAI, and Claude &mdash; fully integrated with 30+ models available) means switching AI providers is a configuration change, not a code change.</p>
        </div>

        <!-- ============================================ -->
        <!-- 6.4  KULLANICI YNETM                      -->
        <!-- ============================================ -->

        <h2 id="sec-6-4" style="margin-top: 48px;">6.4 Kullan&inodot;c&inodot; Y&ouml;netimi (User Management)</h2>

        <h3>6.4.1 Purpose and Business Context</h3>

        <p>User Management is the <strong>identity and authorization backbone</strong> of the entire ERP. Every other module &mdash; Hammadde, Teknik, Sipari&#351;, &Uuml;retim, Stok, Lab, Admin &mdash; depends on this submodule to answer two questions: <em>&ldquo;Who is this person?&rdquo;</em> (authentication) and <em>&ldquo;What are they allowed to do?&rdquo;</em> (authorization). It is the most complex submodule in the system because it implements a <strong>hybrid permission model</strong>: legacy role-based access layered with a granular page+button permission system that controls visibility down to individual UI buttons across 8 modules, 26+ pages, and 200+ actions.</p>

        <p>The factory has three core user archetypes: <strong>Super Admin</strong> (full system control, desktop), <strong>Lab User</strong> (quality testing, desktop), and <strong>Operator</strong> (machine operation, mobile kiosk). Beyond these, the system supports unlimited custom user types created on-the-fly, each with hand-crafted permissions.</p>

        <h3>6.4.2 Database Schema &mdash; 6 Tables, Joined-Table Inheritance</h3>

        <h4>users (17 columns) &mdash; The Core Identity Table</h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Details</th></tr>
            <tr><td><code>id</code></td><td>Integer PK</td><td>Auto-increment, indexed</td></tr>
            <tr><td><code>email</code></td><td>String(320)</td><td>Unique, indexed, not null</td></tr>
            <tr><td><code>hashed_password</code></td><td>String(1024)</td><td>bcrypt hash, not null</td></tr>
            <tr><td><code>is_active</code></td><td>Boolean</td><td>Default True</td></tr>
            <tr><td><code>is_superuser</code></td><td>Boolean</td><td>Default False (FastAPI-Users legacy)</td></tr>
            <tr><td><code>is_verified</code></td><td>Boolean</td><td>Default False</td></tr>
            <tr><td><code>username</code></td><td>String(50)</td><td>Unique, indexed, not null</td></tr>
            <tr><td><code>user_type</code></td><td>String(50)</td><td><code>super_admin</code>, <code>lab_user</code>, <code>operator</code>, or custom</td></tr>
            <tr><td><code>full_name</code></td><td>String(100)</td><td>Display name</td></tr>
            <tr><td><code>status</code></td><td>String(20)</td><td><code>active</code> / <code>inactive</code> / <code>suspended</code></td></tr>
            <tr><td><code>last_login</code></td><td>DateTime</td><td>Updated on each login</td></tr>
            <tr><td><code>created_at</code></td><td>DateTime</td><td>UTC timestamp</td></tr>
            <tr><td><code>updated_at</code></td><td>DateTime</td><td>Auto-updated on change</td></tr>
            <tr><td><code>preferred_interface</code></td><td>String(20)</td><td><code>mobile</code> / <code>desktop</code> / <code>auto</code></td></tr>
            <tr><td><code>device_info</code></td><td>JSON</td><td>Last known device details</td></tr>
            <tr><td><code>permissions</code></td><td>Text</td><td><strong>JSON string</strong> &mdash; the granular permission object (pages + buttons)</td></tr>
            <tr><td><code>force_password_change</code></td><td>Boolean</td><td>Default False, set True on password reset</td></tr>
        </table>

        <h4>Joined-Table Inheritance &mdash; Extension Tables</h4>
        <p>Each user type has a dedicated extension table linked via <code>user_id FK &rarr; users.id</code> (unique, one-to-one). These store type-specific metadata:</p>

        <table>
            <tr><th>Table</th><th>Extra Columns</th><th>Purpose</th></tr>
            <tr><td><code>super_admins</code></td><td>admin_level (system/module/user), permissions (JSON list), access_logs (JSON list)</td><td>Admin hierarchy, action audit trail</td></tr>
            <tr><td><code>lab_users</code></td><td>lab_department, certifications (JSON list), test_specializations (JSON list), shift_schedule (JSON dict)</td><td>Lab-specific qualifications and shifts</td></tr>
            <tr><td><code>operators</code></td><td>assigned_machines (JSON list), shift_schedule (JSON dict), skill_level (junior/senior/expert), certifications (JSON list)</td><td>Machine assignments and skill tracking</td></tr>
        </table>

        <p>SQLAlchemy backrefs provide navigation: <code>user.super_admin_profile</code>, <code>user.lab_user_profile</code>, <code>user.operator_profile</code>.</p>

        <h4>user_sessions (11 columns)</h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Details</th></tr>
            <tr><td><code>id</code></td><td>Integer PK</td><td>Auto-increment</td></tr>
            <tr><td><code>user_id</code></td><td>Integer FK</td><td>References <code>users.id</code></td></tr>
            <tr><td><code>session_token</code></td><td>String(255)</td><td>Unique, indexed &mdash; the JWT access token</td></tr>
            <tr><td><code>refresh_token</code></td><td>String(255)</td><td>Unique, indexed</td></tr>
            <tr><td><code>login_time</code></td><td>DateTime</td><td>When session started</td></tr>
            <tr><td><code>logout_time</code></td><td>DateTime</td><td>Null until logout</td></tr>
            <tr><td><code>expires_at</code></td><td>DateTime</td><td>Token expiry timestamp</td></tr>
            <tr><td><code>ip_address</code></td><td>String(45)</td><td>IPv6-ready</td></tr>
            <tr><td><code>user_agent</code></td><td>Text</td><td>Browser/device string</td></tr>
            <tr><td><code>device_type</code></td><td>String(20)</td><td><code>mobile</code> / <code>desktop</code> / <code>tablet</code></td></tr>
            <tr><td><code>status</code></td><td>String(20)</td><td><code>active</code> / <code>expired</code> / <code>terminated</code></td></tr>
        </table>

        <h4>user_roles (7 columns)</h4>
        <p>Reusable permission templates (role definitions). Each role stores a full permission JSON that can be quickly applied to users.</p>
        <table>
            <tr><th>Column</th><th>Type</th><th>Details</th></tr>
            <tr><td><code>id</code></td><td>Integer PK</td><td>Auto-increment</td></tr>
            <tr><td><code>name</code></td><td>String(50)</td><td>Unique, e.g. &ldquo;Lab Technician&rdquo;</td></tr>
            <tr><td><code>description</code></td><td>Text</td><td>Human-readable role description</td></tr>
            <tr><td><code>permissions</code></td><td>Text</td><td>JSON string &mdash; full permission structure</td></tr>
            <tr><td><code>is_system</code></td><td>Boolean</td><td>System roles cannot be deleted</td></tr>
            <tr><td><code>created_at</code></td><td>DateTime</td><td>UTC</td></tr>
            <tr><td><code>updated_at</code></td><td>DateTime</td><td>Auto-updated</td></tr>
        </table>

        <h4>user_activity_logs (11 columns)</h4>
        <p>Audit trail for every administrative action on users. <code>username</code> is denormalized for fast reads.</p>
        <table>
            <tr><th>Column</th><th>Type</th><th>Details</th></tr>
            <tr><td><code>user_id</code></td><td>Integer FK</td><td>Who performed the action</td></tr>
            <tr><td><code>username</code></td><td>String(50)</td><td>Denormalized</td></tr>
            <tr><td><code>action</code></td><td>String(50)</td><td><code>create_user</code>, <code>update_user</code>, <code>suspend_user</code>, <code>delete_user</code>, <code>reset_password</code></td></tr>
            <tr><td><code>module</code></td><td>String(50)</td><td>Always <code>user_management</code></td></tr>
            <tr><td><code>target_type</code></td><td>String(50)</td><td>Always <code>user</code></td></tr>
            <tr><td><code>target_id</code></td><td>Integer</td><td>ID of affected user</td></tr>
            <tr><td><code>details</code></td><td>Text</td><td>JSON string with extra context</td></tr>
            <tr><td><code>ip_address</code></td><td>String(50)</td><td>Client IP</td></tr>
            <tr><td><code>user_agent</code></td><td>Text</td><td>Browser string</td></tr>
            <tr><td><code>created_at</code></td><td>DateTime</td><td>When action occurred</td></tr>
        </table>

        <h3>6.4.3 Authentication System &mdash; JWT Tokens and Sessions</h3>

        <h4>Token Architecture</h4>
        <div class="flow">
            <span class="flow-step">Login (username + password)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">bcrypt verify</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Generate Access Token (HS256)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Generate Refresh Token</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Create UserSession row</span>
        </div>

        <table>
            <tr><th>Token Type</th><th>Expiry</th><th>Payload</th><th>Purpose</th></tr>
            <tr><td><strong>Access Token</strong></td><td>12 hours (default)</td><td><code>sub</code> (user_id), <code>username</code>, <code>user_type</code>, <code>permissions</code>, <code>type: "access"</code></td><td>Authenticate every API request via <code>Authorization: Bearer</code> header</td></tr>
            <tr><td><strong>Refresh Token</strong></td><td>7 days</td><td><code>sub</code> (user_id), <code>type: "refresh"</code>, <code>jti</code> (unique token ID)</td><td>Generate new access token without re-login</td></tr>
            <tr><td><strong>Operator Kiosk Token</strong></td><td><strong>6 months</strong></td><td>Same as access token</td><td>Factory floor kiosk phones &mdash; avoid frequent re-login</td></tr>
        </table>

        <p>The 6-month token is triggered by a hardcoded check: <code>if user.username == 'operator'</code>. This is deliberate &mdash; the shared <code>operator</code> account is used on wall-mounted phones that should stay logged in for months.</p>

        <h4>Password System</h4>
        <table>
            <tr><th>Operation</th><th>Implementation</th></tr>
            <tr><td>Hashing</td><td><code>passlib</code> with <code>bcrypt</code> scheme. <code>CryptContext(schemes=["bcrypt"], deprecated="auto")</code></td></tr>
            <tr><td>Verification</td><td><code>pwd_context.verify(plain, hashed)</code> &mdash; constant-time comparison</td></tr>
            <tr><td>Auto-Generation</td><td><code>secrets.choice()</code> over <code>ascii_letters + digits + "!@#$%"</code>, 12 characters</td></tr>
            <tr><td>Validation (Create)</td><td>Min 8 chars, must contain uppercase + lowercase + digit</td></tr>
            <tr><td>Validation (Login)</td><td>Min 5 chars (allows simple operator passwords like <code>op123</code>)</td></tr>
        </table>

        <h4>Login Flow End-to-End</h4>
        <ol>
            <li>User submits username + password to <code>POST /auth/login</code></li>
            <li>Backend queries user by username <em>or</em> email (case-insensitive)</li>
            <li>Checks <code>is_active == True</code> and <code>status != "suspended"</code></li>
            <li>Verifies password with bcrypt</li>
            <li>Updates <code>last_login</code> timestamp</li>
            <li>Builds JWT payload with <code>user_id</code>, <code>username</code>, <code>user_type</code>, <code>permissions</code></li>
            <li>If operator account: sets 6-month expiry; otherwise 12-hour expiry</li>
            <li>Creates <code>UserSession</code> row (session_token, refresh_token, device info, IP, expiry)</li>
            <li>Returns <code>{ access_token, refresh_token, expires_in, user }</code></li>
            <li>Frontend stores tokens and user in <code>localStorage</code> (keys: <code>solen_auth_token</code>, <code>solen_refresh_token</code>, <code>solen_current_user</code>)</li>
            <li>Operators redirect to <code>/production</code>, others to <code>/welcome</code></li>
        </ol>

        <h4>Kiosk Auto-Login</h4>
        <p>The Login page detects factory kiosk devices in two ways:</p>
        <ol>
            <li><strong>User-Agent detection:</strong> checks for &ldquo;FullyKiosk&rdquo; in the browser user-agent string (Fully Kiosk Browser is the app running on factory phones)</li>
            <li><strong>Secret URL token:</strong> checks for <code>?kiosk=SOLEN_FACTORY_2024_KIOSK_SECRET</code> in the URL</li>
        </ol>
        <p>If either matches, the page automatically logs in as <code>operator</code> / <code>op123</code> and redirects to <code>/production</code> &mdash; no human interaction needed.</p>

        <h4>Token Refresh and Logout</h4>
        <ol>
            <li><strong>Refresh:</strong> <code>POST /auth/refresh</code> with refresh token &rarr; validates, generates new access token, does <em>not</em> create new session</li>
            <li><strong>Logout:</strong> <code>POST /auth/logout</code> with access token &rarr; sets session <code>status = "terminated"</code> and <code>logout_time</code> &rarr; frontend clears <code>localStorage</code></li>
        </ol>

        <h3>6.4.4 The Permission System &mdash; The Most Complex Part</h3>

        <p>The authorization system is a <strong>5-layer architecture</strong> that controls access from route-level down to individual button visibility:</p>

        <div class="flow">
            <span class="flow-step">Layer 1: Permission Manifest (static definition)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Layer 2: Button Registry (dynamic runtime)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Layer 3: Access Control (route guards)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Layer 4: Permission Utilities (component-level)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Layer 5: Backend Enforcement (API-level)</span>
        </div>

        <h4>Layer 1: The Permission Manifest (<code>permissionManifest.ts</code>, 565 lines)</h4>

        <p>A static, centralized definition of <strong>every permissionable action</strong> in the entire ERP. Structured as Module &rarr; Page &rarr; Button hierarchy:</p>

        <table>
            <tr><th>Module</th><th>Pages</th><th>Total Buttons</th><th>Highlights</th></tr>
            <tr><td><strong>Dashboard</strong></td><td>1 (Main)</td><td>3</td><td>access_page, view_stats, view_charts</td></tr>
            <tr><td><strong>Hammadde</strong></td><td>3 (Giri&#351;, Liste, Tedarik&ccedil;i)</td><td>30</td><td>12 for entry forms, 11 for list (incl. hard_delete), 7 for suppliers</td></tr>
            <tr><td><strong>Lab</strong></td><td>2 (Panel, Test)</td><td>5</td><td>Lab access, test management</td></tr>
            <tr><td><strong>Teknik</strong></td><td>6 (Panel, Kablo Tasar&inodot;m, Makine, Standart, Kablo DB, Markalama)</td><td>32</td><td>11 for Cable Playground alone</td></tr>
            <tr><td><strong>Sipari&#351;</strong></td><td>3 (Sipari&#351;lerim, Olu&#351;tur, M&uuml;&#351;teri)</td><td>17</td><td>Order CRUD, customer management</td></tr>
            <tr><td><strong>&Uuml;retim</strong></td><td>12 (Planlama, 6 machine pages, Aktarma, Paletleme, Sevkiyat, Liste, Ge&ccedil;mi&#351;)</td><td>~40</td><td>Start/stop production per machine type, planning, shipping</td></tr>
            <tr><td><strong>Stok</strong></td><td>3 (&Uuml;r&uuml;n, Hammadde, Projeksiyon)</td><td>14</td><td>View, export, filter, adjust stock</td></tr>
            <tr><td><strong>Admin</strong></td><td>3 (Yazd&inodot;rma &#304;zleme, Yaz&inodot;c&inodot;, Kullan&inodot;c&inodot;)</td><td>22</td><td>9 for User Management (incl. manage_permissions)</td></tr>
        </table>

        <p><strong>Total: 8 modules, 26+ pages, 200+ buttons.</strong></p>

        <p>Each button has metadata:</p>
        <pre><span class="keyword">interface</span> <span class="string">ButtonPermission</span> {
  id: <span class="keyword">string</span>;       <span class="comment">// e.g. "hard_delete_material"</span>
  label: <span class="keyword">string</span>;    <span class="comment">// e.g. "Kalc Silme"</span>
  description: <span class="keyword">string</span>; <span class="comment">// e.g. "Malzemeyi veritabanndan tamamen siler"</span>
  critical?: <span class="keyword">boolean</span>; <span class="comment">// true = highlighted in red in permission editor</span>
}</pre>

        <p>The manifest also exports helper functions: <code>createEmptyPermissions()</code> (all false), <code>createFullPermissions()</code> (all true), <code>getAllPages()</code>, <code>getAllButtons()</code>.</p>

        <h4>Layer 2: Button Registry (<code>buttonRegistry.ts</code>, 130 lines)</h4>

        <p>A dynamic complement to the static manifest. Components can register their buttons at runtime via <code>registerPageButtons()</code>. The <code>buildCompleteManifest()</code> function merges static manifest pages with dynamic registry buttons. This allows new pages to self-register permissions without modifying the central manifest file.</p>

        <h4>Layer 3: Access Control &mdash; Route Guards (<code>access.ts</code>, 93 lines)</h4>

        <p>Runs on every route change. Parses the current user&rsquo;s <code>permissions</code> JSON and returns boolean flags consumed by <code>routes.ts</code>:</p>

        <pre><span class="keyword">return</span> {
  canAdmin: canAccessModule(<span class="string">'admin'</span>),     <span class="comment">// guards /admin/* routes</span>
  canLab: canAccessModule(<span class="string">'lab'</span>),         <span class="comment">// guards /lab/* routes</span>
  canProduction: canAccessModule(<span class="string">'production'</span>),
  canHammadde: canAccessModule(<span class="string">'hammadde'</span>),
  canTeknik: canAccessModule(<span class="string">'teknik'</span>),
  canSiparis: canAccessModule(<span class="string">'siparis'</span>),
  canStok: canAccessModule(<span class="string">'stok'</span>),
  canDashboard: canAccessModule(<span class="string">'dashboard'</span>),
  <span class="comment">// ... plus sub-page guards</span>
};</pre>

        <p><code>canAccessModule(prefix)</code> returns true if <em>any</em> page under that module has <code>access: true</code>. Routes use these as guards: <code>access: 'canAdmin'</code> in route config.</p>

        <h4>Layer 4: Permission Utilities &mdash; Component-Level (<code>permissions.ts</code>, 145 lines)</h4>

        <p>Provides fine-grained checks for individual components:</p>
        <ul>
            <li><code>canAccessModule(module)</code> &mdash; is module enabled?</li>
            <li><code>canPerformAction(module, action)</code> &mdash; is specific action allowed?</li>
            <li><code>hasSpecialPermission(permission)</code> &mdash; e.g. <code>hard_delete</code></li>
        </ul>

        <p>Also exports React wrapper components:</p>
        <ul>
            <li><code>&lt;PermissionButton module="hammadde" action="delete"&gt;</code> &mdash; shows/hides button based on permission</li>
            <li><code>&lt;PermissionGuard module="admin" action="manage"&gt;</code> &mdash; wraps any component with permission check, shows fallback if denied</li>
        </ul>

        <h4>Layer 5: Backend Enforcement (<code>permission_checker.py</code>, 200 lines)</h4>

        <p>The server-side mirror. Even if a user bypasses the frontend, the backend enforces permissions:</p>

        <table>
            <tr><th>Function</th><th>What It Checks</th></tr>
            <tr><td><code>check_user_permission(user, page_id, button_id)</code></td><td>Parses user&rsquo;s <code>permissions</code> JSON, checks <code>pages[page_id].access</code> and <code>pages[page_id].buttons[button_id]</code></td></tr>
            <tr><td><code>has_special_permission(user, permission)</code></td><td>Checks <code>special_permissions[permission]</code></td></tr>
            <tr><td><code>is_permitted_user(user, required_types)</code></td><td>Legacy role-based check + granular fallback</td></tr>
            <tr><td><code>check_permission_smart(user, types, page, button)</code></td><td><strong>Hybrid</strong>: tries legacy role check first, then granular, then graceful fallback. Backward-compatible.</td></tr>
            <tr><td><code>require_permission(page_id, button_id)</code></td><td>Returns a FastAPI dependency that raises 403 if permission denied</td></tr>
        </table>

        <p><strong>Super admin bypass:</strong> Every permission function checks <code>user.user_type == "super_admin"</code> first and returns <code>True</code> immediately.</p>

        <h4>The Permission JSON Structure</h4>
        <p>Stored as a JSON string in the <code>users.permissions</code> column. This is the contract between frontend and backend:</p>

        <pre>{
  <span class="string">"pages"</span>: {
    <span class="string">"hammadde.hammadde_girisi"</span>: {
      <span class="string">"access"</span>: <span class="keyword">true</span>,
      <span class="string">"buttons"</span>: {
        <span class="string">"add_copper"</span>: <span class="keyword">true</span>,
        <span class="string">"add_tin"</span>: <span class="keyword">false</span>,
        <span class="string">"submit_form"</span>: <span class="keyword">true</span>,
        <span class="string">"print_qr"</span>: <span class="keyword">true</span>
      }
    },
    <span class="string">"production.planning"</span>: {
      <span class="string">"access"</span>: <span class="keyword">false</span>,
      <span class="string">"buttons"</span>: {}
    }
  }
}</pre>

        <h3>6.4.5 API Contract &mdash; 14 Endpoints (9 User Management + 5 Auth)</h3>

        <h4>Authentication Endpoints (5)</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/auth/login</code></td><td>Authenticate with username/password. Returns access + refresh tokens and user object.</td></tr>
            <tr><td><code>POST</code></td><td><code>/auth/logout</code></td><td>Terminate session. Sets session status to &ldquo;terminated&rdquo; and records logout time.</td></tr>
            <tr><td><code>POST</code></td><td><code>/auth/refresh</code></td><td>Exchange refresh token for new access token. Does not create new session.</td></tr>
            <tr><td><code>GET</code></td><td><code>/auth/me</code></td><td>Get current user info from token. Used by frontend to restore state on page refresh.</td></tr>
            <tr><td><code>GET</code></td><td><code>/auth/health</code></td><td>Auth service health check: database connection, version, uptime.</td></tr>
        </table>

        <h4>User Management Endpoints (9)</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>Permission</th><th>What It Does</th></tr>
            <tr><td><code>GET</code></td><td><code>/user-management/users/list</code></td><td>super_admin</td><td>List all users. Supports <code>?status_filter</code> and <code>?user_type</code> query params. Parses permissions JSON.</td></tr>
            <tr><td><code>GET</code></td><td><code>/user-management/operators</code></td><td>any authenticated</td><td>List active users (for operator dropdowns in other modules). Returns only id, username, full_name.</td></tr>
            <tr><td><code>POST</code></td><td><code>/user-management/users/create</code></td><td>super_admin</td><td>Create user. Validates username/email uniqueness. Auto-generates password if not provided. Stores permissions JSON. Logs activity.</td></tr>
            <tr><td><code>PUT</code></td><td><code>/user-management/users/{id}</code></td><td>super_admin</td><td>Update user fields (username, email, name, type, status, permissions, password). Logs activity.</td></tr>
            <tr><td><code>POST</code></td><td><code>/user-management/users/{id}/suspend</code></td><td>super_admin</td><td>Toggle between <code>active</code> and <code>suspended</code>. Logs activity.</td></tr>
            <tr><td><code>DELETE</code></td><td><code>/user-management/users/{id}</code></td><td>super_admin</td><td>Permanently delete user. Self-deletion blocked (400). Logs activity.</td></tr>
            <tr><td><code>POST</code></td><td><code>/user-management/users/{id}/reset-password</code></td><td>super_admin</td><td>Generate new 12-char password. Sets <code>force_password_change = True</code>. Returns password (one-time). Logs activity.</td></tr>
            <tr><td><code>GET</code></td><td><code>/user-management/roles/list</code></td><td>super_admin</td><td>List all role templates with parsed permissions.</td></tr>
            <tr><td><code>GET</code></td><td><code>/user-management/activity-logs</code></td><td>super_admin</td><td>Query activity logs. Supports <code>?user_id</code>, <code>?module</code>, <code>?action</code>, <code>?limit</code> filters.</td></tr>
        </table>

        <h3>6.4.6 CRUD Flow</h3>

        <p><strong>Create (New User):</strong></p>
        <ol>
            <li>Click &ldquo;Yeni Kullan&inodot;c&inodot;&rdquo; button &rarr; modal opens with 3 tabs</li>
            <li><strong>Tab 1 &ndash; Temel Bilgiler:</strong> fill username (required, alphanumeric + underscore), email (validated), full name, password (optional &mdash; auto-generated if empty), user type (select or create custom type inline), status, force password change checkbox</li>
            <li><strong>Tab 2 &ndash; Yetkiler:</strong> the permission editor &mdash; 4 quick templates at top (&ldquo;T&uuml;m Yetkiler&rdquo;, &ldquo;Hi&ccedil;biri&rdquo;, &ldquo;Operat&ouml;r Varsay&inodot;lan&rdquo;, &ldquo;Lab User Varsay&inodot;lan&rdquo;), then scrollable module list. Each module shows pages, each page has: access switch, &ldquo;T&uuml;m&uuml;&rdquo;/&ldquo;Hi&ccedil;biri&rdquo; quick toggles, individual button checkboxes. Critical buttons highlighted in red. Enabling a button auto-enables page access. Disabling page access disables all its buttons.</li>
            <li><strong>Tab 3 &ndash; &Ouml;nizleme:</strong> read-only summary showing accessible modules &rarr; pages &rarr; enabled buttons with color-coded tags</li>
            <li>Click &ldquo;Olu&#351;tur&rdquo; &rarr; <code>POST /user-management/users/create</code> with <code>{ username, email, full_name, user_type, status, permissions, force_password_change, return_password: true }</code></li>
            <li>Backend validates uniqueness (username, email), hashes password with bcrypt, stores user + permissions JSON, logs activity</li>
            <li>If password was auto-generated: modal shows the generated password with a warning &ldquo;Bu &#351;ifreyi not edin, tekrar g&ouml;sterilmeyecektir&rdquo; (Note this password, it won&rsquo;t be shown again)</li>
        </ol>

        <p><strong>Read (User List):</strong></p>
        <ol>
            <li>Navigate to <code>/admin/user-management</code> &rarr; ProTable loads via <code>GET /user-management/users/list</code></li>
            <li>7 columns: ID (fixed left), Kullan&inodot;c&inodot; (username + full_name), Email, Tip (colored tag), Durum (colored tag), Son Giri&#351; (UTC &rarr; Istanbul), &#304;&#351;lemler (fixed right)</li>
            <li>Client-side search filters across username, email, full_name, user_type, and status simultaneously</li>
            <li>Pagination: 10/20/50/100 per page</li>
            <li>ProTable density and column settings controls</li>
        </ol>

        <p><strong>Update (Edit User):</strong></p>
        <ol>
            <li>Click edit icon (EditOutlined) on user row &rarr; same 3-tab modal opens, pre-filled with user data</li>
            <li>Existing permissions loaded and parsed (handles string JSON &rarr; object conversion)</li>
            <li>Password field is hidden in edit mode (use Reset Password for that)</li>
            <li>Modify any field or permission &rarr; click &ldquo;G&uuml;ncelle&rdquo;</li>
            <li><code>PUT /user-management/users/{id}</code> with changed fields + full permissions object</li>
            <li>Backend validates, updates, logs activity</li>
        </ol>

        <p><strong>Delete (Permanent):</strong></p>
        <ol>
            <li>Click delete icon (DeleteOutlined, danger) on user row</li>
            <li>Confirmation modal: &ldquo;Bu kullan&inodot;c&inodot;y&inodot; silmek istedi&gbreve;inizden emin misiniz?&rdquo;</li>
            <li><code>DELETE /user-management/users/{id}</code></li>
            <li>Backend blocks self-deletion (400 error). Hard deletes user record. Logs activity.</li>
        </ol>

        <p><strong>Suspend / Activate:</strong></p>
        <ol>
            <li>Click stop icon (StopOutlined) on user row</li>
            <li><code>POST /user-management/users/{id}/suspend</code></li>
            <li>Toggles status between <code>active</code> and <code>suspended</code>. Suspended users cannot log in.</li>
        </ol>

        <p><strong>Reset Password:</strong></p>
        <ol>
            <li>Click key icon (KeyOutlined) on user row</li>
            <li><code>POST /user-management/users/{id}/reset-password</code></li>
            <li>Backend generates cryptographically secure 12-character password, hashes with bcrypt, sets <code>force_password_change = True</code></li>
            <li>Modal shows new password once with warning. Admin must communicate it to user out-of-band.</li>
        </ol>

        <h3>6.4.7 User Types and Their Differences</h3>

        <table>
            <tr><th></th><th>Super Admin</th><th>Lab User</th><th>Operator</th><th>Custom Types</th></tr>
            <tr><td><strong>Interface</strong></td><td>Desktop</td><td>Desktop</td><td>Mobile (kiosk)</td><td>Configurable</td></tr>
            <tr><td><strong>Dashboard Route</strong></td><td><code>/welcome</code></td><td><code>/lab/dashboard</code></td><td><code>/production</code></td><td>Defaults to <code>/welcome</code></td></tr>
            <tr><td><strong>Token Expiry</strong></td><td>12 hours</td><td>12 hours</td><td><strong>6 months</strong></td><td>12 hours</td></tr>
            <tr><td><strong>Permission Bypass</strong></td><td><strong>Yes</strong> &mdash; all checks return True</td><td>No</td><td>No</td><td>No</td></tr>
            <tr><td><strong>Default Modules</strong></td><td>All (<code>all_access</code>)</td><td>Lab, Hammadde</td><td>Production</td><td>None (manual)</td></tr>
            <tr><td><strong>Extension Table</strong></td><td><code>super_admins</code></td><td><code>lab_users</code></td><td><code>operators</code></td><td>None</td></tr>
            <tr><td><strong>Can Manage Users</strong></td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr>
            <tr><td><strong>Auto-Login</strong></td><td>No</td><td>No</td><td><strong>Yes</strong> (kiosk)</td><td>No</td></tr>
            <tr><td><strong>Menu Access</strong></td><td><code>["all"]</code></td><td><code>["lab", "welcome"]</code></td><td><code>["production"]</code></td><td>Based on permissions</td></tr>
        </table>

        <p>Custom types (e.g. <code>teknik_user</code>, <code>bakim_user</code>, <code>data</code>) can be created directly in the User Management modal &mdash; an input field at the bottom of the user type dropdown allows typing a new type name. The <code>user_type</code> field is a free <code>String(50)</code>, not an enum, enabling this flexibility.</p>

        <h3>6.4.8 Frontend Architecture</h3>

        <p>Single file: <code>src/pages/Admin/UserManagement/index.tsx</code> (960 lines). Route: <code>/admin/user-management</code>.</p>

        <h4>ProTable (7 columns)</h4>
        <table>
            <tr><th>#</th><th>Column</th><th>Width</th><th>Details</th></tr>
            <tr><td>1</td><td>ID</td><td>60px, fixed left</td><td>Numeric</td></tr>
            <tr><td>2</td><td>Kullan&inodot;c&inodot;</td><td>140px</td><td>Username (bold) + full_name below</td></tr>
            <tr><td>3</td><td>Email</td><td>200px</td><td>Ellipsis on overflow</td></tr>
            <tr><td>4</td><td>Tip</td><td>110px</td><td>Colored tag: super_admin (red), lab_user (blue), operator (green), teknik_user (purple), bakim_user (orange)</td></tr>
            <tr><td>5</td><td>Durum</td><td>100px</td><td>active (success/green), suspended (warning/yellow), inactive (default/gray)</td></tr>
            <tr><td>6</td><td>Son Giri&#351;</td><td>140px</td><td><code>dayjs.utc(date).tz('Europe/Istanbul')</code> formatted</td></tr>
            <tr><td>7</td><td>&#304;&#351;lemler</td><td>160px, fixed right</td><td>4 action buttons (edit, reset password, suspend, delete)</td></tr>
        </table>

        <h4>The Permission Editor (Tab 2 of Modal)</h4>
        <p>The most complex UI component in the entire ERP. For each of the 8 modules:</p>
        <ol>
            <li><strong>Module header:</strong> module name with icon</li>
            <li><strong>Page cards:</strong> each page as a Card component with:
                <ul>
                    <li>Header: <code>Switch</code> for page access + page label + tag showing &ldquo;X/Y&rdquo; enabled buttons count</li>
                    <li>Quick actions: &ldquo;T&uuml;m&uuml;&rdquo; (enable all) / &ldquo;Hi&ccedil;biri&rdquo; (disable all) text buttons</li>
                    <li>Button grid: <code>Row</code>/<code>Col</code> layout of <code>Checkbox</code> components for each button</li>
                    <li>Critical buttons: highlighted with red text and distinct styling</li>
                </ul>
            </li>
            <li><strong>Smart toggling:</strong> enabling any button auto-enables its page access. Disabling page access cascades to disable all buttons.</li>
        </ol>

        <h4>Quick Templates</h4>
        <table>
            <tr><th>Template</th><th>Effect</th></tr>
            <tr><td>&ldquo;T&uuml;m Yetkiler&rdquo;</td><td><code>createFullPermissions()</code> &mdash; every page and every button set to <code>true</code></td></tr>
            <tr><td>&ldquo;Hi&ccedil;biri&rdquo;</td><td><code>createEmptyPermissions()</code> &mdash; everything <code>false</code></td></tr>
            <tr><td>&ldquo;Operat&ouml;r Varsay&inodot;lan&rdquo;</td><td>Production module enabled (except planning page, which is excluded)</td></tr>
            <tr><td>&ldquo;Lab User Varsay&inodot;lan&rdquo;</td><td>Lab and Hammadde modules enabled</td></tr>
        </table>

        <h4>Preview Tab (Tab 3)</h4>
        <p>Read-only summary using Card components. Shows only accessible modules/pages. Each page lists its enabled buttons as Tags (critical ones in red). Provides a quick visual confirmation before saving.</p>

        <h3>6.4.9 Activity Logging &mdash; Admin Audit Trail</h3>

        <p>Every user management action is logged to <code>user_activity_logs</code> via the <code>log_activity()</code> helper function:</p>

        <table>
            <tr><th>Action</th><th>Logged Fields</th></tr>
            <tr><td><code>create_user</code></td><td>Who created, target user ID, username, IP, user agent</td></tr>
            <tr><td><code>update_user</code></td><td>Who updated, target user ID, changed fields in details</td></tr>
            <tr><td><code>suspend_user</code></td><td>Who suspended, target user ID, new status</td></tr>
            <tr><td><code>delete_user</code></td><td>Who deleted, target user ID</td></tr>
            <tr><td><code>reset_password</code></td><td>Who reset, target user ID (password never logged)</td></tr>
        </table>

        <p>Logs are queryable via <code>GET /user-management/activity-logs</code> with filters for user_id, module, action, and limit (default 200). Only super admins can access this endpoint.</p>

        <h3>6.4.10 Permission Model</h3>

        <p>User Management requires the highest privilege level in the system:</p>

        <table>
            <tr><th>Action</th><th>Required Role</th></tr>
            <tr><td>View user list</td><td>super_admin only</td></tr>
            <tr><td>Create user</td><td>super_admin only</td></tr>
            <tr><td>Edit user</td><td>super_admin only</td></tr>
            <tr><td>Manage permissions</td><td>super_admin only</td></tr>
            <tr><td>Suspend / activate user</td><td>super_admin only</td></tr>
            <tr><td>Reset password</td><td>super_admin only</td></tr>
            <tr><td>Delete user</td><td>super_admin only (self-deletion blocked)</td></tr>
            <tr><td>View activity logs</td><td>super_admin only</td></tr>
            <tr><td>List operators (dropdown)</td><td>any authenticated user</td></tr>
        </table>

        <p>In the permission manifest, User Management has 9 registered buttons: <code>access_page</code>, <code>view_users</code>, <code>create_user</code>, <code>edit_user</code>, <code>manage_permissions</code>, <code>suspend_user</code>, <code>reset_password</code>, <code>delete_user</code>, <code>view_activity_logs</code>.</p>

        <p>Backend enforces role-based access: every endpoint except <code>/user-management/operators</code> checks <code>current_user.user_type != "super_admin"</code> and returns 403 if it fails.</p>

        <h3>6.4.11 How User Management Connects to the Rest of the System</h3>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>&rarr; Every Module (Authentication)</h4>
                <p>Every API endpoint in the entire ERP depends on User Management&rsquo;s authentication. The <code>get_current_user_dependency()</code> FastAPI dependency is imported and used across all route files. JWT tokens issued here are the <em>only</em> way to access any protected resource.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Every Module (Authorization)</h4>
                <p>The <code>permissions</code> JSON stored per user controls what every user sees and can do across all 8 modules. Route guards (<code>access.ts</code>), component guards (<code>PermissionGuard</code>), and backend checks (<code>permission_checker.py</code>) all read from this same permission structure.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Hammadde Giri&#351;i (Operator Dropdown)</h4>
                <p>The <code>GET /user-management/operators</code> endpoint feeds operator/user dropdowns in material entry forms and production pages. Any authenticated user can access this, enabling forms across modules to show &ldquo;who entered this material.&rdquo;</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Production Pages (Kiosk Auto-Login)</h4>
                <p>The kiosk auto-login system (<code>?kiosk=...</code> token or Fully Kiosk detection) bypasses the login form entirely for factory floor devices, landing directly on <code>/production</code> with the shared operator account&rsquo;s 6-month token.</p>
            </div>
        </div>

        <div class="discovery">
            <p style="margin-bottom: 0;"><strong>Architecture insight:</strong> User Management is the <em>gravitational center</em> of the entire ERP. Every module depends on it, but it depends on no other module. The 5-layer permission architecture (manifest &rarr; registry &rarr; route guards &rarr; component guards &rarr; backend enforcement) ensures defense-in-depth: even if one layer is bypassed, others still enforce access control. The hybrid permission model (legacy role-based + granular page+button JSON) is a pragmatic engineering decision &mdash; the system evolved from simple role checks to granular permissions without requiring a full rewrite. The <code>check_permission_smart()</code> function embodies this: it tries the new system first, falls back to legacy, and gracefully degrades. The 200+ button manifest makes this the finest-grained permission system possible without going to individual record-level access control. The 6-month kiosk token is an unusual but practical choice for a factory environment where shared devices on the production floor need to &ldquo;just work&rdquo; without IT intervention every 12 hours.</p>
        </div>

    </main>
</body>
</html>
