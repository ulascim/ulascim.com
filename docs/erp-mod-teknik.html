<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="../favicon.png">
    <link rel="apple-touch-icon" href="../apple-touch-icon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teknik Module | Cable Factory ERP</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #f3f3f3;
            --fg: #000000;
            --gray-100: #f3f4f6;
            --gray-300: #d1d5db;
            --positive: #16a34a;
            --negative: #dc2626;
            --accent: #2563eb;
            --turquoise: #00b5ad;
        }
        body { font-family: 'IBM Plex Mono', monospace; background: var(--bg); color: var(--fg); font-size: 12px; line-height: 1.3; }
        .nav { position: sticky; top: 0; z-index: 50; border-bottom: 2px solid var(--fg); background: var(--bg); }
        .nav-container { max-width: 1400px; margin: 0 auto; padding: 0 64px; height: 56px; display: flex; align-items: center; }
        .nav-left { display: flex; align-items: center; gap: 12px; }
        .nav-logo { font-size: 18px; font-weight: 700; letter-spacing: 2px; text-decoration: none; color: var(--fg); }
        .nav-right { margin-left: auto; }
        .nav-link-small { color: var(--fg); text-decoration: underline; font-size: 11px; }
        .nav-divider { color: var(--fg); font-size: 14px; font-weight: 300; }
        .report { max-width: 1400px; margin: 0 auto; padding: 24px 64px; }
        .report h1 { font-size: 28px; margin-bottom: 8px; letter-spacing: 2px; }
        .report h2 { font-size: 18px; margin-top: 36px; margin-bottom: 12px; border-bottom: 2px solid #000; padding-bottom: 4px; }
        .report h3 { font-size: 14px; margin-top: 20px; margin-bottom: 8px; }
        .report h4 { font-size: 12px; margin-top: 14px; margin-bottom: 6px; }
        .report p { font-size: 13px; line-height: 1.6; margin-bottom: 12px; }
        .report ul { font-size: 13px; margin: 12px 0; padding-left: 20px; }
        .report li { margin-bottom: 6px; line-height: 1.5; }
        .report ol { font-size: 13px; margin: 12px 0; padding-left: 20px; }
        .report ol li { margin-bottom: 6px; line-height: 1.5; }
        .report .subtitle { font-size: 14px; color: #666; margin-bottom: 4px; }
        .report .authors { font-size: 12px; color: #888; margin-bottom: 32px; }
        .report code { background: #e5e5e0; padding: 1px 5px; font-size: 12px; }
        .report pre { background: #1a1a2e; color: #e0e0e0; padding: 16px; margin: 12px 0; overflow-x: auto; font-size: 12px; line-height: 1.5; border: 2px solid #000; }
        .report pre .comment { color: #6a9955; }
        .report pre .keyword { color: #569cd6; }
        .report pre .string { color: #ce9178; }
        .report pre .decorator { color: #dcdcaa; }
        .report .abstract { background: #f5f5f0; padding: 16px; margin: 20px 0; border-left: 3px solid #000; }
        .report .finding { background: #fffbe6; padding: 12px; margin: 12px 0; border: 1px solid #e6d600; }
        .report .warning { background: #fee2e2; padding: 12px; margin: 12px 0; border: 1px solid #dc2626; }
        .report .discovery { background: #e6ffe6; padding: 12px; margin: 12px 0; border: 1px solid #0a0; }
        .report .insight { background: #eff6ff; padding: 12px; margin: 12px 0; border: 1px solid #2563eb; }
        .report .philosophy { background: #faf5ff; padding: 12px; margin: 12px 0; border: 1px solid #7c3aed; }
        .stat-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin: 16px 0; }
        .stat-grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin: 16px 0; }
        .stat-box { background: #f3f4f6; padding: 12px; text-align: center; border: 2px solid #000; }
        .stat-box .value { font-size: 24px; font-weight: bold; }
        .stat-box .label { font-size: 10px; color: #666; margin-top: 2px; }
        .report table { width: auto; border-collapse: collapse; border: 2px solid #000; margin: 16px 0; }
        .report tr:first-child { background: #f3f4f6; border-bottom: 2px solid #000; }
        .report th { padding: 4px 10px; text-align: left; font-size: 0.65rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.03em; white-space: nowrap; border-right: 2px solid #000; background: #f3f4f6; }
        .report th:last-child { border-right: none; }
        .report tr:not(:first-child) { border-bottom: 1px solid #d1d5db; }
        .report tr:last-child { border-bottom: none; }
        .report td { padding: 4px 10px; font-size: 0.75rem; border-right: 2px solid #000; }
        .report td:last-child { border-right: none; }
        .report tr:not(:first-child):hover { background: rgba(0,0,0,0.02); }
        .flow { display: flex; align-items: center; gap: 8px; margin: 16px 0; flex-wrap: wrap; }
        .flow-box { padding: 8px 14px; border: 2px solid #000; font-size: 12px; font-weight: 700; text-align: center; min-width: 100px; }
        .flow-arrow { font-size: 18px; font-weight: 700; }
        .flow-box.done { background: #dcfce7; border-color: #16a34a; }
        .flow-box.active { background: #dbeafe; border-color: #2563eb; }
        .flow-box.pending { background: #f3f4f6; }
        .arch-box { background: #fff; border: 2px solid #000; padding: 16px; margin: 12px 0; }
        .arch-box h4 { font-size: 14px; margin-bottom: 8px; margin-top: 0; }
        .arch-box p { font-size: 12px; line-height: 1.5; }
        .arch-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 16px; margin: 16px 0; }
        .back-link { display: inline-block; font-size: 12px; color: #666; text-decoration: none; margin-bottom: 24px; padding: 8px 0; }
        .back-link:hover { color: #000; }
        .back-link::before { content: "\2190  "; }
        .good { color: #16a34a; font-weight: 700; }
        .bad { color: #dc2626; font-weight: 700; }

        .submod-card { background: #fff; border: 2px solid #000; padding: 16px; margin: 10px 0; display: flex; align-items: flex-start; gap: 16px; }
        .submod-num { background: #000; color: #fff; font-size: 13px; font-weight: 700; min-width: 36px; height: 36px; padding: 0 8px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .submod-body { flex: 1; }
        .submod-body h4 { font-size: 14px; margin: 0 0 4px 0; }
        .submod-body p { font-size: 12px; color: #555; margin: 0 0 6px 0; line-height: 1.4; }
        .submod-tags { display: flex; gap: 6px; flex-wrap: wrap; }
        .submod-tag { font-size: 10px; padding: 2px 6px; background: #f3f4f6; border: 1px solid #d1d5db; }

        @media (max-width: 768px) {
            .report { padding: 16px; }
            .nav-container { padding: 0 16px; }
            .stat-grid, .stat-grid-3 { grid-template-columns: repeat(2, 1fr); }
            .flow { flex-direction: column; align-items: stretch; }
            .flow-arrow { transform: rotate(90deg); text-align: center; }
            .arch-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="nav-container">
            <div class="nav-left">
                <a href="erp-system.html" class="nav-logo">ERP SYSTEM</a>
            </div>
            <div class="nav-right">
                <a href="erp-mod-teknik-tr.html" class="nav-link-small">TR</a>
                <span class="nav-divider">|</span>
                <a href="erp-mod-teknik.html" class="nav-link-small" style="font-weight: 700;">EN</a>
            </div>
        </div>
    </nav>

    <main class="report">
        <a href="erp-deep-dives.html" class="back-link">Back to Modules</a>
        <h1>TEKNIK &mdash; THE FOUNDATION MODULE</h1>
        <p class="subtitle">Everything downstream depends on this. No order, no production, no test can exist without data defined here.</p>
        <p class="authors">February 2026 &bull; Solen Kablo &bull; Living Document</p>

        <div class="abstract">
            <p style="margin-bottom: 0;"><strong>Teknik is where a cable is born.</strong> Before a single meter of wire is drawn, before a customer order is placed, before a test can be assigned &mdash; someone has to define what cables the factory can produce, what machines exist, what parameters those machines accept, what standards the cables must pass, and what gets printed on them. Teknik holds all of this. It is the single source of truth that every other module reads from but never writes to.</p>
        </div>

        <div class="stat-grid">
            <div class="stat-box">
                <div class="value" style="color: var(--accent);">6</div>
                <div class="label">SUBMODULES</div>
            </div>
            <div class="stat-box">
                <div class="value" style="color: var(--turquoise);">~75</div>
                <div class="label">API ENDPOINTS</div>
            </div>
            <div class="stat-box">
                <div class="value">12</div>
                <div class="label">DATABASE TABLES</div>
            </div>
            <div class="stat-box">
                <div class="value" style="color: var(--positive);">4000+</div>
                <div class="label">LINES OF FRONTEND</div>
            </div>
        </div>

        <!-- ============================================ -->
        <h2>1. WHAT TEKNIK DOES</h2>
        <!-- ============================================ -->

        <p>The Teknik module answers five questions that the entire factory depends on:</p>

        <ol>
            <li><strong>What cables can we produce?</strong> &mdash; Cable Playground designs them. Cable Database stores the approved results. Every cable is defined as an ordered sequence of machine steps with exact parameters.</li>
            <li><strong>What machines do we have?</strong> &mdash; Machine Management registers all 7 machine types with their physical capabilities (speed ranges, diameter limits, thickness ranges). The Playground uses these to validate that a design is physically producible.</li>
            <li><strong>What quality standards must be met?</strong> &mdash; Standards Management defines every test (IEC-EN, UL, SLN) with parameters, pass/fail criteria, and test frequencies. These are linked to cable designs &mdash; each design knows exactly which tests it requires at which production step.</li>
            <li><strong>What gets printed on the cable?</strong> &mdash; Markalama defines the ordered word arrays that the extruder prints during production (company name, standard, voltage, cross-section, etc.).</li>
            <li><strong>Who operates the machines?</strong> &mdash; Operator Management maintains the registry of production operators who are assigned to sessions.</li>
        </ol>

        <div class="finding">
            <p style="margin-bottom: 0;"><strong>Zero dependencies.</strong> Teknik depends on no other business module. It reads only from the <code>users</code> table (for <code>created_by</code> tracking). Every other module &mdash; Sipari&scedil;, &Uuml;retim, Lab, Stok &mdash; depends on Teknik. This makes it the foundation layer of the entire system.</p>
        </div>

        <!-- ============================================ -->
        <h2>2. THE DATA FLOW</h2>
        <!-- ============================================ -->

        <p>Data flows in one direction: from Teknik outward. Here is how each submodule feeds the rest of the system.</p>

        <div class="flow">
            <div class="flow-box" style="background: #faf5ff; border-color: #7c3aed;">MACHINES<br><span style="font-size:9px;color:#666;">Define capabilities</span></div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box" style="background: #eff6ff; border-color: #2563eb;">PLAYGROUND<br><span style="font-size:9px;color:#666;">Design cables</span></div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box" style="background: #dcfce7; border-color: #16a34a;">CABLE DB<br><span style="font-size:9px;color:#666;">Store approved</span></div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box" style="background: #fffbe6; border-color: #f59e0b;">ORDERS<br><span style="font-size:9px;color:#666;">Select cables</span></div>
        </div>

        <div class="flow">
            <div class="flow-box" style="background: #faf5ff; border-color: #7c3aed;">STANDARDS<br><span style="font-size:9px;color:#666;">Define tests</span></div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box" style="background: #eff6ff; border-color: #2563eb;">PLAYGROUND<br><span style="font-size:9px;color:#666;">Assign to steps</span></div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box" style="background: #dcfce7; border-color: #16a34a;">CABLE DB<br><span style="font-size:9px;color:#666;">Store requirements</span></div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box" style="background: #fce7f3; border-color: #db2777;">LAB<br><span style="font-size:9px;color:#666;">Execute tests</span></div>
        </div>

        <p>The Cable Database is the convergence point. It stores the finalized design as structured JSON: the complete production flow, every half-product that will be created, the bill of raw materials, and all test requirements. When Sipari&scedil; calculates material needs or &Uuml;retim generates work cards, they read from Cable Database &mdash; never from the Playground or Machines directly.</p>

        <!-- ============================================ -->
        <h2>3. THE DATABASE LAYER</h2>
        <!-- ============================================ -->

        <p>12 tables serve the Teknik module. They fall into four groups:</p>

        <h3>Machine Tables (7)</h3>
        <p>One table per machine type. Each stores the physical capabilities of that machine as min/max/increment ranges. The system generates dropdown options by stepping through these ranges.</p>

        <table>
            <tr><th>Table</th><th>Unique Config</th><th>Input Code</th></tr>
            <tr><td><code>kabatel_cekme_machines</code></td><td>speed, tav (anneal current), output diameter</td><td>A</td></tr>
            <tr><td><code>kalaylama_machines</code></td><td>speed, tin thickness (&mu;m)</td><td>X</td></tr>
            <tr><td><code>incetel_cekme_machines</code></td><td>speed, input count, output diameter, tav</td><td>&mdash;</td></tr>
            <tr><td><code>buncher_machines</code></td><td>speed, hatve (lay length), input count</td><td>Z,T,U</td></tr>
            <tr><td><code>extruder_machines</code></td><td>speed, insulation thickness, sheath thickness</td><td>T,Z</td></tr>
            <tr><td><code>ebeam_machines</code></td><td>speed, radiation level (kGy)</td><td>&mdash;</td></tr>
            <tr><td><code>aktarma_machines</code></td><td>(brand/model only)</td><td>&mdash;</td></tr>
        </table>

        <p>Every configurable parameter has a database-level <code>CHECK</code> constraint: <code>max &gt; min</code>, <code>increment &gt; 0</code>, <code>min &ge; 0</code>. This means invalid machine configurations are impossible to save &mdash; the database itself enforces physical sanity.</p>

        <h3>Design Tables (3)</h3>

        <table>
            <tr><th>Table</th><th>Purpose</th><th>Key Fields</th></tr>
            <tr><td><code>cable_designs</code></td><td>Design sessions from the Playground</td><td><code>design_code</code> (unique), <code>standard</code> (EN/UL/SLN), <code>cross_section</code>, <code>design_data</code> (JSON)</td></tr>
            <tr><td><code>design_steps</code></td><td>Individual production steps within a design</td><td><code>step_number</code>, <code>machine_type</code>, <code>configuration</code> (JSON), <code>inputs/outputs</code> (JSON), <code>tests</code> (JSON)</td></tr>
            <tr><td><code>cable_database</code></td><td>Finalized, approved cable definitions</td><td><code>cable_code</code> (unique), <code>production_flow</code> (JSON), <code>half_products</code> (JSON), <code>raw_materials</code> (JSON), <code>test_requirements</code> (JSON)</td></tr>
        </table>

        <p>The relationship: <code>CableDesign</code> &rarr; many <code>DesignStep</code> (cascade delete) &rarr; one <code>CableDatabase</code> entry on finalize. The Cable Database stores everything as denormalized JSON blobs &mdash; intentionally. When the Material Calculator needs to compute copper requirements for an order, it reads one row from <code>cable_database</code> and has the complete production flow without any joins.</p>

        <h3>Quality Tables (2)</h3>

        <table>
            <tr><th>Table</th><th>Purpose</th><th>Key Fields</th></tr>
            <tr><td><code>test_standards</code></td><td>Test definitions</td><td><code>standard_category</code> (IEC-EN/UL/SLN), <code>test_name</code>, <code>standard_number</code>, <code>test_samples</code></td></tr>
            <tr><td><code>test_parameters</code></td><td>Parameters within a test</td><td><code>parameter_name</code>, <code>parameter_unit</code>, <code>parameter_order</code>, <code>is_required</code></td></tr>
        </table>

        <p>A test standard has N parameters (cascade delete). When a test is assigned to a design step in the Playground, the standard ID and frequency (start/end/every reel) are embedded in the step&rsquo;s JSON. This means the Cable Database carries the complete test map &mdash; Lab knows exactly what to test and when, without querying Teknik at production time.</p>

        <h3>Supporting Tables</h3>

        <table>
            <tr><th>Table</th><th>Purpose</th></tr>
            <tr><td><code>product_codes</code></td><td>SHA-256 hashed product identifiers for stock deduplication. <code>system_code</code> (human-readable, e.g. <code>HALF_BN_73X030</code>) + <code>spec_hash</code> (deterministic hash of specifications). Ensures identical products across different designs share the same stock pool.</td></tr>
            <tr><td><code>markings</code></td><td>Cable printing templates. <code>name</code> (unique) + <code>words</code> (JSON array of strings). Each order-cable references a marking.</td></tr>
            <tr><td><code>production_operators</code></td><td>Operator registry. <code>name</code> (unique). Referenced by production sessions.</td></tr>
        </table>

        <!-- ============================================ -->
        <h2>4. THE BACKEND ARCHITECTURE</h2>
        <!-- ============================================ -->

        <p>The Teknik backend is split into <strong>6 route files</strong> mounted under <code>/api/teknik/</code> and <strong>6 utility modules</strong> that power the Playground&rsquo;s simulation engine.</p>

        <h3>Route Files</h3>
        <table>
            <tr><th>File</th><th>Prefix</th><th>Endpoints</th><th>Responsibility</th></tr>
            <tr><td><code>machine_routes.py</code></td><td>/teknik/machines</td><td>~45</td><td>CRUD + options for 7 machine types</td></tr>
            <tr><td><code>design_routes.py</code></td><td>/teknik/design</td><td>~22</td><td>Playground sessions, steps, config, undo/redo, finalize</td></tr>
            <tr><td><code>cable_database_routes.py</code></td><td>/teknik/cable-database</td><td>~15</td><td>Approved cables, product codes, analytics</td></tr>
            <tr><td><code>standards_routes.py</code></td><td>/teknik/standards</td><td>~12</td><td>Test standards, parameters, results</td></tr>
            <tr><td><code>marking_routes.py</code></td><td>/markings</td><td>~6</td><td>Marking template CRUD</td></tr>
            <tr><td><code>operator_routes.py</code></td><td>/operators</td><td>~4</td><td>Operator CRUD</td></tr>
        </table>

        <h3>Playground Engine (6 utility modules)</h3>
        <p>The Cable Playground is not a simple CRUD page &mdash; it is a <strong>real-time simulation engine</strong> that runs entirely in-memory on the backend. These are the modules that make it work:</p>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>Session Manager</h4>
                <p>In-memory session storage. Each design session has a unique ID, a step counter, undo/redo stacks (max 50 states), autosave timer (default 30s), and checkpoint/restore for atomic transactions.</p>
            </div>
            <div class="arch-box">
                <h4>Progression Engine</h4>
                <p>Tracks what exists after each step. Items have codes, quantities, statuses (active/consumed). Each machine type has its own processing function that consumes inputs and produces outputs with correct codes (e.g., <code>BN_73X030</code>).</p>
            </div>
            <div class="arch-box">
                <h4>Form Integration</h4>
                <p>Populates frontend dropdowns from database + current progression state. Filters available inputs per machine type (e.g., Buncher only sees Z/T/U coded items). Validates quantities before configuration.</p>
            </div>
            <div class="arch-box">
                <h4>DB Integration</h4>
                <p>Reads real machine tables. Calculates capability intersection when multiple machines are selected &mdash; returns only parameter values ALL selected machines can produce.</p>
            </div>
            <div class="arch-box">
                <h4>Validation Engine</h4>
                <p>Two validators: <code>MachineValidator</code> checks configs against machine ranges. <code>ProductionFlowValidator</code> checks step sequences, parallel groups, and test assignments.</p>
            </div>
            <div class="arch-box">
                <h4>Code Generator</h4>
                <p>Deterministic product code generation. SHA-256 spec hashing for stock deduplication. Human-readable system codes (e.g., <code>HALF_KC_180</code>). Final cable codes encode standard, cross-section, structure, and layer thicknesses.</p>
            </div>
        </div>

        <!-- ============================================ -->
        <h2>5. THE FRONTEND</h2>
        <!-- ============================================ -->

        <p>7 pages under <code>/teknik/*</code>, protected by the <code>canTeknik</code> access flag. All pages use Ant Design Pro&rsquo;s <code>ProTable</code> with Turkish locale, client-side search, and blurred backdrop modals.</p>

        <table>
            <tr><th>Route</th><th>Page</th><th>Lines</th><th>Complexity</th></tr>
            <tr><td>/teknik/dashboard</td><td>Dashboard</td><td>~400</td><td>Stats, quick actions, recent designs</td></tr>
            <tr><td>/teknik/playground</td><td>Cable Playground</td><td>~4,300</td><td>SVG canvas, 6 config forms, 3 view modes, undo/redo, autosave</td></tr>
            <tr><td>/teknik/cable-database</td><td>Cable Database</td><td>~690</td><td>Table + detail drawer with 3 tabs</td></tr>
            <tr><td>/teknik/machines</td><td>Machine Management</td><td>~730</td><td>7 machine tabs, dynamic forms</td></tr>
            <tr><td>/teknik/standards</td><td>Standards</td><td>~550</td><td>Standards CRUD + parameter forms</td></tr>
            <tr><td>/teknik/markalama</td><td>Markalama</td><td>~370</td><td>Marking templates with word arrays</td></tr>
            <tr><td>/teknik/operator-yonetimi</td><td>Operators</td><td>~280</td><td>Simple name CRUD</td></tr>
        </table>

        <p>The Cable Playground alone accounts for more than half the frontend code. It is built as a modular component system: a <code>usePlayground</code> hook manages state and API calls, <code>FlowCanvas</code> renders the SVG diagram, <code>MachineLibrary</code> is the sidebar palette, <code>ConfigurationDrawer</code> holds 6 machine-specific forms (1,215 lines), and <code>ProgressionPanel</code> shows real-time material tracking.</p>

        <!-- ============================================ -->
        <h2>6. THE SUBMODULES</h2>
        <!-- ============================================ -->

        <p>The sections that follow document each submodule in full detail &mdash; every form field, every API endpoint, every database column, every validation rule, and the design decisions behind them. Ordered from foundational data to the tools that consume it.</p>

        <div class="submod-card">
            <div class="submod-num">6.1</div>
            <div class="submod-body">
                <h4>Machine Management</h4>
                <p>CRUD for all 7 factory machine types. Each type has a unique configuration schema with min/max/increment ranges. The Playground reads these to validate that designs are physically producible.</p>
                <div class="submod-tags">
                    <span class="submod-tag">~45 ENDPOINTS</span>
                    <span class="submod-tag">7 MACHINE TYPES</span>
                    <span class="submod-tag">DB CHECK CONSTRAINTS</span>
                </div>
            </div>
        </div>

        <div class="submod-card">
            <div class="submod-num">6.2</div>
            <div class="submod-body">
                <h4>Standards Management</h4>
                <p>Test standard definitions with dynamic parameters, pass/fail criteria, and test frequency rules. Linked to cable designs at the step level &mdash; the Lab module reads these to know what to test and when.</p>
                <div class="submod-tags">
                    <span class="submod-tag">12 ENDPOINTS</span>
                    <span class="submod-tag">3 CATEGORIES</span>
                    <span class="submod-tag">DYNAMIC PARAMETERS</span>
                </div>
            </div>
        </div>

        <div class="submod-card">
            <div class="submod-num">6.3</div>
            <div class="submod-body">
                <h4>Operator Management</h4>
                <p>Production operator registry. Operators are assigned to production sessions by the person starting the session &mdash; they don&rsquo;t need system logins. Simple name CRUD with uniqueness constraint.</p>
                <div class="submod-tags">
                    <span class="submod-tag">4 ENDPOINTS</span>
                    <span class="submod-tag">SIMPLE CRUD</span>
                </div>
            </div>
        </div>

        <div class="submod-card">
            <div class="submod-num">6.4</div>
            <div class="submod-body">
                <h4>Markalama (Cable Marking)</h4>
                <p>Marking templates define the text printed on cables during extrusion. Stored as ordered word arrays with variable support (<code>{CABLE_SIZE}</code>, <code>{YEAR}</code>, etc.). Each order-cable references a marking template.</p>
                <div class="submod-tags">
                    <span class="submod-tag">6 ENDPOINTS</span>
                    <span class="submod-tag">WORD ARRAYS</span>
                    <span class="submod-tag">VARIABLES</span>
                </div>
            </div>
        </div>

        <div class="submod-card">
            <div class="submod-num">6.5</div>
            <div class="submod-body">
                <h4>Cable Playground</h4>
                <p>The visual cable design workshop. Drag machines onto a canvas, configure parameters, watch the production flow build in real-time. Session-based, in-memory simulation with undo/redo, autosave, and three view modes. Where all foundational data &mdash; machines, standards, operators, markings &mdash; converges into a cable design.</p>
                <div class="submod-tags">
                    <span class="submod-tag">22 ENDPOINTS</span>
                    <span class="submod-tag">4,300 LOC</span>
                    <span class="submod-tag">6 UTILITY MODULES</span>
                    <span class="submod-tag">SVG CANVAS</span>
                </div>
            </div>
        </div>

        <div class="submod-card">
            <div class="submod-num">6.6</div>
            <div class="submod-body">
                <h4>Cable Database</h4>
                <p>The library of approved cable designs. Each entry stores the complete production flow, half-product tree, bill of materials, and test requirements as structured JSON. The single source of truth for Orders and Production.</p>
                <div class="submod-tags">
                    <span class="submod-tag">15 ENDPOINTS</span>
                    <span class="submod-tag">SHA-256 PRODUCT CODES</span>
                    <span class="submod-tag">ANALYTICS</span>
                </div>
            </div>
        </div>

        <div class="philosophy">
            <p style="margin-bottom: 0;"><strong>What follows:</strong> Each submodule above will be expanded into a full section with database schemas, complete API endpoint documentation, frontend form fields, validation rules, code snippets, and the reasoning behind key design decisions.</p>
        </div>

        <!-- ============================================ -->
        <h2>6.1 MACHINE MANAGEMENT</h2>
        <!-- ============================================ -->

        <p>Before you can design a cable, you need to tell the system what machines the factory has. Machine Management is the registry of every physical machine on the production floor &mdash; its brand, model, and most importantly, its <strong>capability ranges</strong>. These ranges (speed min/max, diameter min/max, etc.) are used throughout the system to generate dropdown options and validate that a cable design is physically producible.</p>

        <div class="insight">
            <p style="margin-bottom: 0;"><strong>Why one table per machine type?</strong> Each machine type has fundamentally different configurable parameters. A Kabatel &Ccedil;ekme has tav (anneal current) and output diameter. A Buncher has hatve (lay length) and input count. An Aktarma has no parameters at all. Rather than a single table with dozens of nullable columns, each type gets its own table with exactly the columns it needs. The database CHECK constraints can then enforce physical sanity per machine type.</p>
        </div>

        <h3>6.1.1 The Seven Machine Types</h3>

        <p>The factory&rsquo;s production line consists of 7 machine types, each performing a specific step in the cable manufacturing process:</p>

        <table>
            <tr><th>#</th><th>Machine Type</th><th>Turkish Name</th><th>What It Does</th><th>Configurable Parameters</th></tr>
            <tr><td>1</td><td>Kabatel &Ccedil;ekme</td><td>Kabatel &Ccedil;ekme</td><td>Draws thick copper rod (8mm filma&scedil;in) into thinner wire</td><td>Speed (m/s), TAV (A), Output Diameter (mm)</td></tr>
            <tr><td>2</td><td>Kalaylama</td><td>Kalaylama</td><td>Coats drawn wire with tin for conductivity and corrosion resistance</td><td>Speed (m/s), Tin Thickness (&mu;m)</td></tr>
            <tr><td>3</td><td>&Idot;ncetel &Ccedil;ekme</td><td>&Idot;ncetel &Ccedil;ekme</td><td>Draws wire to even finer diameters, optionally from multiple inputs</td><td>Speed (m/s), Input Count, Output Diameter (mm), TAV (A)</td></tr>
            <tr><td>4</td><td>Buncher</td><td>Buncher</td><td>Twists multiple wires into a bundle (strand)</td><td>Speed (m/s), Hatve/Lay Length, Input Count, Twist Direction (S/Z)</td></tr>
            <tr><td>5</td><td>Extruder</td><td>Ekstr&uuml;der</td><td>Applies insulation and/or sheath layers (plastic coating)</td><td>Speed (m/s), Insulation Thickness (mm), Sheath Thickness (mm)</td></tr>
            <tr><td>6</td><td>E-beam</td><td>E-beam</td><td>Cross-links insulation via electron beam radiation</td><td>Speed (m/s), Radiation Level (kGy)</td></tr>
            <tr><td>7</td><td>Aktarma</td><td>Aktarma</td><td>Transfers/rewinds cable between spools (no transformation)</td><td>None (brand/model only)</td></tr>
        </table>

        <h3>6.1.2 Database Schema</h3>

        <p>7 tables, one per machine type. All share a common structure (id, brand, model, is_active, created_by, timestamps) plus type-specific parameter columns stored as min/max/increment triplets.</p>

        <h4>Common Columns (all 7 tables)</h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Nullable</th><th>Default</th><th>Notes</th></tr>
            <tr><td><code>id</code></td><td>Integer</td><td>No</td><td>Auto</td><td>Primary key, indexed</td></tr>
            <tr><td><code>brand</code></td><td>String(100)</td><td>No</td><td>&mdash;</td><td>Machine manufacturer</td></tr>
            <tr><td><code>model</code></td><td>String(100)</td><td>Yes</td><td>NULL</td><td>Machine model designation</td></tr>
            <tr><td><code>is_active</code></td><td>Boolean</td><td>No</td><td>True</td><td>Indexed; soft-delete flag</td></tr>
            <tr><td><code>created_by</code></td><td>Integer</td><td>Yes</td><td>NULL</td><td>FK &rarr; <code>users.id</code></td></tr>
            <tr><td><code>created_at</code></td><td>DateTime</td><td>No</td><td>utcnow</td><td>Creation timestamp</td></tr>
            <tr><td><code>updated_at</code></td><td>DateTime</td><td>No</td><td>utcnow</td><td>Auto-updates on change</td></tr>
        </table>

        <h4>Kabatel &Ccedil;ekme &mdash; <code>kabatel_cekme_machines</code></h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Unit</th><th>CHECK Constraint</th></tr>
            <tr><td><code>speed_min</code></td><td>Float</td><td>m/s</td><td>&ge; 0</td></tr>
            <tr><td><code>speed_max</code></td><td>Float</td><td>m/s</td><td>&gt; speed_min</td></tr>
            <tr><td><code>speed_increment</code></td><td>Float</td><td>m/s</td><td>&gt; 0</td></tr>
            <tr><td><code>tav_min</code></td><td>Float</td><td>Ampere</td><td>&ge; 0</td></tr>
            <tr><td><code>tav_max</code></td><td>Float</td><td>Ampere</td><td>&gt; tav_min</td></tr>
            <tr><td><code>tav_increment</code></td><td>Float</td><td>Ampere</td><td>&gt; 0</td></tr>
            <tr><td><code>output_min</code></td><td>Float</td><td>mm</td><td>&gt; 0</td></tr>
            <tr><td><code>output_max</code></td><td>Float</td><td>mm</td><td>&gt; output_min</td></tr>
            <tr><td><code>output_increment</code></td><td>Float</td><td>mm</td><td>&gt; 0</td></tr>
            <tr><td><code>input_type</code></td><td>String(50)</td><td>&mdash;</td><td>Default: <code>'8mm_filma&scedil;in'</code></td></tr>
            <tr><td><code>input_code</code></td><td>String(10)</td><td>&mdash;</td><td>Default: <code>'A'</code></td></tr>
        </table>

        <h4>Kalaylama &mdash; <code>kalaylama_machines</code></h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Unit</th><th>CHECK Constraint</th></tr>
            <tr><td><code>speed_min</code></td><td>Float</td><td>m/s</td><td>&ge; 0</td></tr>
            <tr><td><code>speed_max</code></td><td>Float</td><td>m/s</td><td>&gt; speed_min</td></tr>
            <tr><td><code>speed_increment</code></td><td>Float</td><td>m/s</td><td>&gt; 0</td></tr>
            <tr><td><code>thickness_min</code></td><td>Float</td><td>&mu;m</td><td>&gt; 0</td></tr>
            <tr><td><code>thickness_max</code></td><td>Float</td><td>&mu;m</td><td>&gt; thickness_min</td></tr>
            <tr><td><code>thickness_increment</code></td><td>Float</td><td>&mu;m</td><td>&gt; 0</td></tr>
            <tr><td><code>input_code</code></td><td>String(10)</td><td>&mdash;</td><td>Default: <code>'X'</code></td></tr>
        </table>

        <h4>&Idot;ncetel &Ccedil;ekme &mdash; <code>incetel_cekme_machines</code></h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Unit</th><th>CHECK Constraint</th></tr>
            <tr><td><code>speed_min/max/increment</code></td><td>Float</td><td>m/s</td><td>Same pattern as above</td></tr>
            <tr><td><code>input_number_min</code></td><td>Integer</td><td>&mdash;</td><td>&ge; 1</td></tr>
            <tr><td><code>input_number_max</code></td><td>Integer</td><td>&mdash;</td><td>&ge; input_number_min</td></tr>
            <tr><td><code>output_min/max/increment</code></td><td>Float</td><td>mm</td><td>Same pattern as above</td></tr>
            <tr><td><code>tav_min/max/increment</code></td><td>Float</td><td>Ampere</td><td>Same pattern as above</td></tr>
        </table>

        <h4>Buncher &mdash; <code>buncher_machines</code></h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Unit</th><th>CHECK Constraint</th></tr>
            <tr><td><code>speed_min/max/increment</code></td><td>Float</td><td>m/s</td><td>Same pattern</td></tr>
            <tr><td><code>hatve_min</code></td><td>Float</td><td>mm</td><td>&gt; 0</td></tr>
            <tr><td><code>hatve_max</code></td><td>Float</td><td>mm</td><td>&gt; hatve_min</td></tr>
            <tr><td><code>hatve_increment</code></td><td>Float</td><td>mm</td><td>&gt; 0</td></tr>
            <tr><td><code>input_number_min</code></td><td>Integer</td><td>&mdash;</td><td>&ge; 0</td></tr>
            <tr><td><code>input_number_max</code></td><td>Integer</td><td>&mdash;</td><td>&ge; input_number_min</td></tr>
            <tr><td><code>accepted_input_codes</code></td><td>Text</td><td>&mdash;</td><td>Default: <code>'Z,T,U'</code></td></tr>
        </table>

        <h4>Extruder &mdash; <code>extruder_machines</code></h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Unit</th><th>CHECK Constraint</th></tr>
            <tr><td><code>speed_min/max/increment</code></td><td>Float</td><td>m/s</td><td>Same pattern</td></tr>
            <tr><td><code>insulation_thickness_min</code></td><td>Float</td><td>mm</td><td>&gt; 0</td></tr>
            <tr><td><code>insulation_thickness_max</code></td><td>Float</td><td>mm</td><td>&gt; insulation_thickness_min</td></tr>
            <tr><td><code>insulation_thickness_increment</code></td><td>Float</td><td>mm</td><td>&gt; 0</td></tr>
            <tr><td><code>sheath_thickness_min</code></td><td>Float</td><td>mm</td><td>&gt; 0</td></tr>
            <tr><td><code>sheath_thickness_max</code></td><td>Float</td><td>mm</td><td>&gt; sheath_thickness_min</td></tr>
            <tr><td><code>sheath_thickness_increment</code></td><td>Float</td><td>mm</td><td>&gt; 0</td></tr>
            <tr><td><code>accepted_input_codes</code></td><td>Text</td><td>&mdash;</td><td>Default: <code>'T,Z'</code></td></tr>
        </table>

        <h4>E-beam &mdash; <code>ebeam_machines</code></h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Unit</th><th>CHECK Constraint</th></tr>
            <tr><td><code>speed_min/max/increment</code></td><td>Float</td><td>m/s</td><td>Same pattern</td></tr>
            <tr><td><code>radiation_level_min</code></td><td>Float</td><td>kGy</td><td>&gt; 0</td></tr>
            <tr><td><code>radiation_level_max</code></td><td>Float</td><td>kGy</td><td>&gt; radiation_level_min</td></tr>
            <tr><td><code>radiation_level_increment</code></td><td>Float</td><td>kGy</td><td>&gt; 0</td></tr>
        </table>

        <h4>Aktarma &mdash; <code>aktarma_machines</code></h4>
        <p>No configurable parameters. Only the common columns (brand, model, is_active, timestamps). No CHECK constraints beyond the common ones.</p>

        <h3>6.1.3 Options Generation &mdash; The Core Mechanism</h3>

        <p>This is the mechanism that makes the entire Machine Management &rarr; Playground pipeline work. When the Playground needs to show dropdown options for a machine parameter, it calls the <code>/options</code> endpoint, which steps through the min/max/increment range and returns every valid value.</p>

        <pre><span class="keyword">def</span> generate_dropdown_options(min_val, max_val, increment):
    options = []
    current = min_val
    <span class="keyword">while</span> current <= max_val:
        options.append(<span class="keyword">round</span>(current, <span class="string">4</span>))  <span class="comment"># Avoid floating point drift</span>
        current += increment
    <span class="keyword">return</span> options

<span class="comment"># Example: machine with speed_min=5, speed_max=25, speed_increment=5</span>
<span class="comment"># â†’ [5.0, 10.0, 15.0, 20.0, 25.0]</span></pre>

        <p><strong>Special cases:</strong></p>
        <ul>
            <li><strong>Integer ranges</strong> (&Idot;ncetel &Ccedil;ekme &amp; Buncher input counts): Uses <code>list(range(min, max + 1))</code> instead of float stepping &mdash; because you can&rsquo;t have 3.5 input wires.</li>
            <li><strong>Hardcoded values</strong> (Buncher twist direction): Returns <code>["S", "Z"]</code> directly &mdash; these are the only two possible twist directions in cable manufacturing.</li>
            <li><strong>No options</strong> (Aktarma): Has no <code>/options</code> endpoint at all &mdash; nothing to configure.</li>
        </ul>

        <div class="finding">
            <p style="margin-bottom: 0;"><strong>Multi-machine intersection:</strong> When the Playground selects multiple machines of the same type, the system calculates the <em>intersection</em> of their capability ranges. If Machine A supports speeds [5, 10, 15, 20] and Machine B supports [10, 15, 20, 25], the dropdown shows [10, 15, 20]. This lives in the Playground&rsquo;s <code>db_integration.py</code>, not here &mdash; but it consumes the options generated by this module.</p>
        </div>

        <h3>6.1.4 API Endpoints</h3>

        <p>38 total endpoints. Each machine type gets 5&ndash;6 endpoints following a consistent pattern (except Aktarma which has no <code>/options</code>).</p>

        <h4>Pattern per machine type (replace <code>{type}</code> with e.g. <code>kabatel-cekme</code>)</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>Permission</th><th>What It Does</th></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/machines/{type}</code></td><td>Authenticated</td><td>List all machines. <code>?active_only=true</code> (default). Ordered by brand, model.</td></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/machines/{type}/{id}</code></td><td>Authenticated</td><td>Single machine detail. Returns 404 if not found.</td></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/machines/{type}/{id}/options</code></td><td>Authenticated</td><td>Generate dropdown values from min/max/increment ranges.</td></tr>
            <tr><td><code>POST</code></td><td><code>/teknik/machines/{type}</code></td><td>super_admin, production_manager</td><td>Create machine. Sets <code>created_by</code>. Broadcasts real-time update.</td></tr>
            <tr><td><code>PUT</code></td><td><code>/teknik/machines/{type}/{id}</code></td><td>super_admin, production_manager</td><td>Partial update. Only provided fields are changed.</td></tr>
            <tr><td><code>DELETE</code></td><td><code>/teknik/machines/{type}/{id}</code></td><td>super_admin only</td><td>Hard delete. Returns 204 No Content.</td></tr>
        </table>

        <h4>Common endpoints</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>What It Does</th></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/machines/types</code></td><td>Returns all 7 type names as string array</td></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/machines/all</code></td><td>Returns all machines of all types in one response, keyed by type name</td></tr>
        </table>

        <h4>Options response shapes per type</h4>
        <table>
            <tr><th>Machine Type</th><th>Options Fields</th></tr>
            <tr><td>Kabatel &Ccedil;ekme</td><td><code>speeds</code>, <code>tavs</code>, <code>output_diameters</code></td></tr>
            <tr><td>Kalaylama</td><td><code>speeds</code>, <code>thicknesses</code></td></tr>
            <tr><td>&Idot;ncetel &Ccedil;ekme</td><td><code>speeds</code>, <code>input_numbers</code> (int), <code>output_diameters</code>, <code>tavs</code></td></tr>
            <tr><td>Buncher</td><td><code>speeds</code>, <code>hatves</code>, <code>input_numbers</code> (int), <code>twist_directions</code> (hardcoded S/Z)</td></tr>
            <tr><td>Extruder</td><td><code>speeds</code>, <code>insulation_thicknesses</code>, <code>sheath_thicknesses</code></td></tr>
            <tr><td>E-beam</td><td><code>speeds</code>, <code>radiation_levels</code></td></tr>
            <tr><td>Aktarma</td><td>&mdash; (no options endpoint)</td></tr>
        </table>

        <h3>6.1.5 Permission Model</h3>

        <p>Uses <code>check_permission_smart()</code> which supports both the legacy user_type system and the granular permission system:</p>

        <table>
            <tr><th>Action</th><th>Legacy Roles</th><th>Granular Permission</th></tr>
            <tr><td>View / List / Options</td><td>Any authenticated user</td><td>Any authenticated user</td></tr>
            <tr><td>Create / Update</td><td>super_admin, production_manager</td><td><code>teknik.machines.create</code> / <code>teknik.machines.edit</code></td></tr>
            <tr><td>Delete</td><td>super_admin only</td><td><code>teknik.machines.delete</code></td></tr>
        </table>

        <h3>6.1.6 Frontend &mdash; The Machines Page</h3>

        <p>Single file: <code>pages/Teknik/Machines/index.tsx</code> (726 lines). Route: <code>/teknik/machines</code>, protected by <code>canTeknik</code> access flag.</p>

        <h4>Page Structure</h4>
        <p>A <code>PageContainer</code> wrapping a <code>Card</code> with 7 <code>Tabs</code> &mdash; one per machine type. Switching tabs fetches the machine list for that type and resets the search text. Default tab: Kabatel &Ccedil;ekme.</p>

        <h4>Table Columns</h4>
        <p>Every tab shows a <code>ProTable</code> with these base columns plus type-specific ones:</p>
        <table>
            <tr><th>Column</th><th>Width</th><th>Notes</th></tr>
            <tr><td>ID</td><td>60px</td><td>Fixed left</td></tr>
            <tr><td>Marka (Brand)</td><td>auto</td><td>Ellipsis enabled</td></tr>
            <tr><td>Model</td><td>auto</td><td>Shows &ldquo;-&rdquo; if empty</td></tr>
            <tr><td><em>Type-specific ranges</em></td><td>auto</td><td>Formatted as &ldquo;min&ndash;max unit&rdquo;</td></tr>
            <tr><td>Durum (Status)</td><td>80px</td><td>Green &ldquo;Aktif&rdquo; / Red &ldquo;Pasif&rdquo; tag</td></tr>
            <tr><td>&Idot;&scedil;lemler (Actions)</td><td>100px</td><td>Fixed right; edit + delete icons</td></tr>
        </table>

        <p><strong>Type-specific columns:</strong></p>
        <ul>
            <li><strong>Kabatel &Ccedil;ekme:</strong> H&#305;z Aral&#305;&#287;&#305; (speed_min&ndash;speed_max m/s), Tav Aral&#305;&#287;&#305; (tav_min&ndash;tav_max A), &Ccedil;&#305;k&#305;&scedil; &Ccedil;ap&#305; (output_min&ndash;output_max mm)</li>
            <li><strong>Kalaylama:</strong> H&#305;z Aral&#305;&#287;&#305;, Kalay Kal&#305;nl&#305;&#287;&#305; (thickness_min&ndash;thickness_max &mu;m)</li>
            <li><strong>&Idot;ncetel &Ccedil;ekme:</strong> Girdi Say&#305;s&#305; (input_number_min&ndash;max), &Ccedil;&#305;k&#305;&scedil; &Ccedil;ap&#305;, Tav Aral&#305;&#287;&#305;</li>
            <li><strong>Buncher:</strong> Girdi Say&#305;s&#305;, Hatve Aral&#305;&#287;&#305; (hatve_min&ndash;max)</li>
            <li><strong>Extruder:</strong> &Idot;zolasyon Kal&#305;nl&#305;&#287;&#305; (insulation min&ndash;max mm), K&#305;l&#305;f Kal&#305;nl&#305;&#287;&#305; (sheath min&ndash;max mm)</li>
            <li><strong>E-beam:</strong> H&#305;z Aral&#305;&#287;&#305;, Radyasyon Seviyesi (radiation_level_min&ndash;max kGy)</li>
            <li><strong>Aktarma:</strong> Base columns only</li>
        </ul>

        <h4>Search &amp; Pagination</h4>
        <p><strong>Search</strong> is client-side: a text input filters the loaded list by ID, brand, model, or status (&ldquo;aktif&rdquo;/&ldquo;pasif&rdquo;). No server-side search needed because machine counts are small (typically &lt;50 per type).</p>
        <p><strong>Pagination</strong> defaults to 10 rows, with options [10, 20, 50, 100]. Total shown as &ldquo;X-Y / Z kay&#305;t&rdquo;.</p>

        <h4>CRUD Flow</h4>

        <p><strong>Create:</strong></p>
        <ol>
            <li>Click &ldquo;Yeni Makine Ekle&rdquo; button in the toolbar</li>
            <li>Modal opens with title &ldquo;Yeni Makine Ekle&rdquo; (600px, blurred backdrop)</li>
            <li>Form shows fields dynamically based on active tab (machine type)</li>
            <li>On submit: <code>POST /api/teknik/machines/{type}</code> with form values</li>
            <li>System fields (<code>id</code>, <code>created_at</code>, <code>updated_at</code>, <code>created_by</code>, <code>input_type</code>, <code>input_code</code>, <code>accepted_input_codes</code>) are automatically excluded</li>
            <li>On success: toast &ldquo;Makine ba&scedil;ar&#305;yla eklendi!&rdquo;, close modal, refresh list</li>
        </ol>

        <p><strong>Edit:</strong></p>
        <ol>
            <li>Click edit icon in the Actions column</li>
            <li>Modal opens with title &ldquo;Makine D&uuml;zenle&rdquo;, pre-filled with current values</li>
            <li>On submit: <code>PUT /api/teknik/machines/{type}/{id}</code> with changed fields only</li>
            <li>On success: toast &ldquo;Makine ba&scedil;ar&#305;yla g&uuml;ncellendi!&rdquo;, close modal, refresh list</li>
        </ol>

        <p><strong>Delete:</strong></p>
        <ol>
            <li>Click delete icon in the Actions column</li>
            <li><code>Popconfirm</code> asks: &ldquo;Bu makineyi devre d&#305;&scedil;&#305; b&#305;rakmak istedi&#287;inize emin misiniz?&rdquo;</li>
            <li>Delete button is disabled if machine is already inactive</li>
            <li>On confirm: <code>DELETE /api/teknik/machines/{type}/{id}</code></li>
            <li>On success: toast &ldquo;Makine devre d&#305;&scedil;&#305; b&#305;rak&#305;ld&#305;!&rdquo;, refresh list</li>
        </ol>

        <h4>Form Fields Per Machine Type</h4>
        <p>The form renders dynamically via <code>renderFormFields()</code> based on the active tab. Common fields (Marka, Model) appear for all types. Type-specific fields use <code>InputNumber</code> with appropriate <code>min</code>, <code>step</code>, and Turkish labels:</p>

        <table>
            <tr><th>Machine Type</th><th>Form Fields (beyond Marka/Model)</th></tr>
            <tr><td>Kabatel &Ccedil;ekme</td><td>H&#305;z: min (0), max (0.1), increment (0.1) &bull; Tav: min (0), max (1), increment (1) &bull; &Ccedil;&#305;k&#305;&scedil; &Ccedil;ap&#305;: min/max/increment (all step 0.01)</td></tr>
            <tr><td>Kalaylama</td><td>H&#305;z: min/max/increment &bull; Kalay Kal&#305;nl&#305;&#287;&#305;: min/max/increment (step 0.1)</td></tr>
            <tr><td>&Idot;ncetel &Ccedil;ekme</td><td>Girdi Say&#305;s&#305;: min (1), max (1) &bull; H&#305;z: min/max/increment &bull; &Ccedil;&#305;k&#305;&scedil; &Ccedil;ap&#305;: min/max/increment (step 0.01) &bull; Tav: min/max/increment</td></tr>
            <tr><td>Buncher</td><td>Girdi Say&#305;s&#305;: min (0), max (1) &bull; H&#305;z: min/max/increment &bull; Hatve: min/max/increment (step 0.1)</td></tr>
            <tr><td>Extruder</td><td>H&#305;z: min/max/increment &bull; &Idot;zolasyon Kal&#305;nl&#305;&#287;&#305;: min/max/increment (step 0.01) &bull; K&#305;l&#305;f Kal&#305;nl&#305;&#287;&#305;: min/max/increment (step 0.01)</td></tr>
            <tr><td>E-beam</td><td>H&#305;z: min/max/increment &bull; Radyasyon Seviyesi: min/max, increment (step 1)</td></tr>
            <tr><td>Aktarma</td><td>None (Marka/Model only)</td></tr>
        </table>

        <h3>6.1.7 Service Layer (Frontend)</h3>

        <p>API calls are wrapped in <code>services/teknik/index.ts</code> with a URL transformation: underscores in the machine type name are replaced with hyphens for the URL path.</p>

        <pre><span class="comment">// kabatel_cekme â†’ kabatel-cekme in URL</span>
<span class="keyword">export async function</span> getMachines(type: MachineType) {
  <span class="keyword">return</span> request(`/api/teknik/machines/${type.replace(<span class="string">'_'</span>, <span class="string">'-'</span>)}`);
}

<span class="keyword">export async function</span> createMachine(type: MachineType, data: <span class="keyword">any</span>) {
  <span class="keyword">return</span> request(`/api/teknik/machines/${type.replace(<span class="string">'_'</span>, <span class="string">'-'</span>)}`, {
    method: <span class="string">'POST'</span>, data
  });
}

<span class="comment">// Same pattern for updateMachine (PUT), deleteMachine (DELETE)</span>
<span class="comment">// getMachineDropdown calls /{id}/dropdown for Playground use</span></pre>

        <h3>6.1.8 How It Connects to Other Submodules</h3>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>&rarr; Cable Playground (6.5)</h4>
                <p>The primary consumer. When you add a machine to the canvas and configure it, the Playground calls the <code>/options</code> endpoint to populate dropdowns. When multiple machines are selected, it reads all their ranges and calculates the intersection &mdash; only showing parameter values all selected machines can physically produce.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Cable Database (6.6)</h4>
                <p>Indirect. Machine IDs are stored in each <code>DesignStep</code>&rsquo;s <code>machine_ids</code> field. The Cable Database stores the finalized design including which specific machines were used, so Production knows which physical machine to assign each step to.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; &Uuml;retim (Production Module)</h4>
                <p>When a work card is generated, the production system reads which machines a cable design requires. Machine IDs stored in the design map directly to the registry maintained here.</p>
            </div>
        </div>

        <div class="discovery">
            <p style="margin-bottom: 0;"><strong>Design principle:</strong> Machine Management is a pure data provider. It knows nothing about designs, orders, or production. It only answers the question &ldquo;what can this machine do?&rdquo; &mdash; everything else is the consumer&rsquo;s responsibility. This keeps the module simple (~726 lines frontend, ~38 endpoints) and makes it the most stable part of the Teknik subsystem.</p>
        </div>

        <!-- ============================================ -->
        <h2>6.2 STANDARDS MANAGEMENT</h2>
        <!-- ============================================ -->

        <p>Every cable sold must pass a set of quality tests defined by international standards bodies (IEC, CENELEC) or the customer. Standards Management is where those tests are defined &mdash; what to measure, how many samples, with which parameters, and what the reference standard number is. These definitions are then embedded into cable designs so that the Lab module knows exactly what to test and when during production.</p>

        <div class="insight">
            <p style="margin-bottom: 0;"><strong>Three layers of quality:</strong> <code>IEC-EN</code> covers European harmonized standards (EN 50618, IEC 60228). <code>UL</code> covers American standards (UL 4703, UL 854). <code>SLN</code> covers Solen&rsquo;s own internal tests &mdash; company-specific checks that go beyond what the standards require. When a cable design is created in the Playground, only tests matching the design&rsquo;s standard category are shown.</p>
        </div>

        <h3>6.2.1 Data Model</h3>

        <p>Three tables work together: standards define what to test, parameters define what to measure within each test, and results store the actual measurements from production.</p>

        <h4><code>test_standards</code></h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Nullable</th><th>Constraints / Default</th><th>Notes</th></tr>
            <tr><td><code>id</code></td><td>Integer</td><td>No</td><td>PK, indexed</td><td>&mdash;</td></tr>
            <tr><td><code>standard_category</code></td><td>String(50)</td><td>No</td><td>CHECK: IN (&lsquo;IEC-EN&rsquo;, &lsquo;UL&rsquo;, &lsquo;SLN&rsquo;)</td><td>Which standards body</td></tr>
            <tr><td><code>test_name</code></td><td>String(200)</td><td>No</td><td>&mdash;</td><td>Turkish test name</td></tr>
            <tr><td><code>test_name_en</code></td><td>String(200)</td><td>Yes</td><td>&mdash;</td><td>English test name</td></tr>
            <tr><td><code>standard_number</code></td><td>String(100)</td><td>Yes</td><td>&mdash;</td><td>e.g. &ldquo;EN 50618&rdquo;, &ldquo;IEC 60228&rdquo;</td></tr>
            <tr><td><code>test_type</code></td><td>String(100)</td><td>Yes</td><td>&mdash;</td><td>Free-form: Mekanik, Elektriksel, G&ouml;rsel, Boyutsal</td></tr>
            <tr><td><code>unit</code></td><td>String(50)</td><td>Yes</td><td>&mdash;</td><td>e.g. &ldquo;ohm/km&rdquo;, &ldquo;kV&rdquo;, &ldquo;N/mm&sup2;&rdquo;</td></tr>
            <tr><td><code>number_of_values</code></td><td>Integer</td><td>No</td><td>Default: 1, CHECK: &ge; 1</td><td>How many values per measurement</td></tr>
            <tr><td><code>test_samples</code></td><td>Integer</td><td>No</td><td>Default: 1, CHECK: &ge; 1</td><td>How many samples to test</td></tr>
            <tr><td><code>test_method</code></td><td>Text</td><td>Yes</td><td>&mdash;</td><td>Free-text test procedure description</td></tr>
            <tr><td><code>is_active</code></td><td>Boolean</td><td>No</td><td>Default: True, indexed</td><td>Soft-delete flag</td></tr>
            <tr><td><code>created_by</code></td><td>Integer</td><td>Yes</td><td>FK &rarr; <code>users.id</code></td><td>&mdash;</td></tr>
            <tr><td><code>created_at</code></td><td>DateTime</td><td>No</td><td>utcnow</td><td>&mdash;</td></tr>
            <tr><td><code>updated_at</code></td><td>DateTime</td><td>No</td><td>utcnow, auto-updates</td><td>&mdash;</td></tr>
        </table>
        <p><strong>Unique constraint:</strong> <code>(standard_category, test_name, standard_number)</code> &mdash; prevents duplicate test definitions within the same standards body.</p>

        <h4><code>test_parameters</code></h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Nullable</th><th>Constraints / Default</th><th>Notes</th></tr>
            <tr><td><code>id</code></td><td>Integer</td><td>No</td><td>PK, indexed</td><td>&mdash;</td></tr>
            <tr><td><code>test_standard_id</code></td><td>Integer</td><td>No</td><td>FK &rarr; <code>test_standards.id</code>, ON DELETE CASCADE</td><td>&mdash;</td></tr>
            <tr><td><code>parameter_name</code></td><td>String(100)</td><td>No</td><td>&mdash;</td><td>e.g. &ldquo;&Ccedil;ekme Dayan&#305;m&#305;&rdquo;, &ldquo;Uzama&rdquo;, &ldquo;Diren&ccedil;&rdquo;</td></tr>
            <tr><td><code>parameter_unit</code></td><td>String(50)</td><td>Yes</td><td>&mdash;</td><td>e.g. &ldquo;N/mm&sup2;&rdquo;, &ldquo;%&rdquo;, &ldquo;ohm/km&rdquo;</td></tr>
            <tr><td><code>parameter_order</code></td><td>Integer</td><td>No</td><td>Default: 1</td><td>Display order in forms</td></tr>
            <tr><td><code>is_required</code></td><td>Boolean</td><td>No</td><td>Default: True</td><td>Must be filled during testing</td></tr>
            <tr><td><code>created_at</code></td><td>DateTime</td><td>No</td><td>utcnow</td><td>&mdash;</td></tr>
        </table>
        <p><strong>Unique constraint:</strong> <code>(test_standard_id, parameter_name)</code> &mdash; no duplicate parameter names within a single test.</p>

        <h4><code>test_results</code></h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Nullable</th><th>Constraints / Default</th><th>Notes</th></tr>
            <tr><td><code>id</code></td><td>Integer</td><td>No</td><td>PK, indexed</td><td>&mdash;</td></tr>
            <tr><td><code>test_standard_id</code></td><td>Integer</td><td>No</td><td>FK &rarr; <code>test_standards.id</code></td><td>Which test was performed</td></tr>
            <tr><td><code>design_step_id</code></td><td>Integer</td><td>Yes</td><td>FK &rarr; <code>design_steps.id</code></td><td>Links result to specific production step</td></tr>
            <tr><td><code>production_session_id</code></td><td>Integer</td><td>Yes</td><td>&mdash;</td><td>Links to production session</td></tr>
            <tr><td><code>cable_batch_code</code></td><td>String(50)</td><td>Yes</td><td>Indexed</td><td>Batch identifier for traceability</td></tr>
            <tr><td><code>test_date</code></td><td>DateTime</td><td>No</td><td>&mdash;</td><td>When the test was performed</td></tr>
            <tr><td><code>tested_by</code></td><td>Integer</td><td>No</td><td>FK &rarr; <code>users.id</code></td><td>Who performed the test</td></tr>
            <tr><td><code>measurements</code></td><td>Text</td><td>No</td><td>&mdash;</td><td>JSON string of measurement data</td></tr>
            <tr><td><code>pass_fail</code></td><td>String(10)</td><td>Yes</td><td>CHECK: IN (&lsquo;PASS&rsquo;, &lsquo;FAIL&rsquo;, &lsquo;PENDING&rsquo;) OR NULL</td><td>Test outcome</td></tr>
            <tr><td><code>notes</code></td><td>Text</td><td>Yes</td><td>&mdash;</td><td>Appended with timestamps by status updates</td></tr>
            <tr><td><code>created_at</code></td><td>DateTime</td><td>No</td><td>utcnow</td><td>&mdash;</td></tr>
        </table>

        <p><strong>Measurement storage:</strong> The <code>measurements</code> column stores a JSON array. Each entry is a <code>MeasurementData</code> object with <code>parameter</code> (name), <code>values</code> (float array), optional <code>unit</code>, and optional per-parameter <code>result</code>. The model has helper methods: <code>get_measurements()</code> parses the JSON, <code>set_measurements()</code> serializes it, and <code>evaluate_result()</code> returns PASS/FAIL/PENDING based on whether all required parameters have values.</p>

        <h3>6.2.2 Relationships</h3>

        <div class="flow">
            <div class="flow-box" style="background: #eff6ff; border-color: #2563eb;">TestStandard</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box" style="background: #faf5ff; border-color: #7c3aed;">N &times; TestParameter<br><span style="font-size:9px;color:#666;">cascade delete</span></div>
        </div>
        <div class="flow">
            <div class="flow-box" style="background: #eff6ff; border-color: #2563eb;">TestStandard</div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box" style="background: #dcfce7; border-color: #16a34a;">N &times; TestResult<br><span style="font-size:9px;color:#666;">no cascade</span></div>
        </div>

        <p>Delete behavior is smart: if a standard has test results, it is <strong>soft deleted</strong> (<code>is_active = false</code>) to preserve result traceability. If it has no results, it is <strong>hard deleted</strong>. Parameters always cascade &mdash; deleting a standard removes all its parameters.</p>

        <h3>6.2.3 API Endpoints</h3>

        <p>12 endpoints organized into three groups: standards CRUD, parameter management, and test results.</p>

        <h4>Test Standards</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>Permission</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/teknik/tests</code></td><td>super_admin, lab_user, production_manager</td><td>Create standard + parameters in one transaction. Checks for duplicate (category + name + number). Flushes DB to get ID before adding parameters.</td></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/tests</code></td><td>Authenticated</td><td>List all. <code>?category=IEC-EN</code>, <code>?active_only=true</code> (default), <code>?search=tensile</code>. Eager-loads parameters. Orders by category then name.</td></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/tests/{id}</code></td><td>Authenticated</td><td>Single standard detail.</td></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/tests/{id}/full</code></td><td>Authenticated</td><td>Full standard with sorted parameters + <code>has_parameters</code> flag. Used by Playground for dynamic form generation.</td></tr>
            <tr><td><code>PUT</code></td><td><code>/teknik/tests/{id}</code></td><td>super_admin, lab_user, production_manager</td><td>Update standard. If <code>parameters</code> provided: <strong>deletes all existing</strong>, creates new ones (full replacement).</td></tr>
            <tr><td><code>DELETE</code></td><td><code>/teknik/tests/{id}</code></td><td>super_admin, lab_user</td><td>Smart delete: soft if has results, hard if no results.</td></tr>
        </table>

        <h4>Test Parameters</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>Permission</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/teknik/tests/{id}/parameters</code></td><td>super_admin, lab_user, production_manager</td><td>Add single parameter to existing standard. Checks duplicate name.</td></tr>
            <tr><td><code>DELETE</code></td><td><code>/teknik/parameters/{id}</code></td><td>super_admin, lab_user</td><td>Hard delete single parameter.</td></tr>
        </table>

        <h4>Test Results</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>Permission</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/teknik/results</code></td><td>lab_user, super_admin</td><td>Create result with measurements JSON. Auto-sets <code>tested_by</code>. Calls <code>evaluate_result()</code> for initial pass/fail.</td></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/results</code></td><td>Authenticated</td><td>List results. Filter by <code>?batch_code</code>, <code>?test_standard_id</code>, <code>?pass_fail</code>. Limit: 1&ndash;200, default 50. Ordered by test_date DESC.</td></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/results/{id}</code></td><td>Authenticated</td><td>Single result with tester name and standard info.</td></tr>
            <tr><td><code>PUT</code></td><td><code>/teknik/results/{id}/status</code></td><td>lab_user, super_admin</td><td>Update pass/fail status. Appends notes with timestamp and username for audit trail.</td></tr>
        </table>

        <h4>Reference Data</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>Returns</th></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/categories</code></td><td><code>["IEC-EN", "UL", "SLN"]</code></td></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/frequencies</code></td><td><code>["&uuml;retim_ba&scedil;&#305;", "&uuml;retim_sonu", "her_ikisi", "her_makara_sonu"]</code></td></tr>
            <tr><td><code>GET</code></td><td><code>/teknik/result-statuses</code></td><td><code>["PASS", "FAIL", "PENDING"]</code></td></tr>
        </table>

        <h3>6.2.4 Test Frequencies &mdash; When Tests Run</h3>

        <p>When a test is assigned to a cable design step in the Playground, the user selects a <strong>frequency</strong> that tells the Lab <em>when</em> to execute the test during production:</p>

        <table>
            <tr><th>Frequency</th><th>Turkish</th><th>Meaning</th></tr>
            <tr><td><code>&uuml;retim_ba&scedil;&#305;</code></td><td>&Uuml;retim Ba&scedil;&#305;</td><td>Test at the start of the production run</td></tr>
            <tr><td><code>&uuml;retim_sonu</code></td><td>&Uuml;retim Sonu</td><td>Test at the end of the production run</td></tr>
            <tr><td><code>her_ikisi</code></td><td>Her &#304;kisi</td><td>Test at both start and end</td></tr>
            <tr><td><code>her_makara_sonu</code></td><td>Her Makara Sonu</td><td>Test at the end of every reel (most frequent)</td></tr>
        </table>

        <h3>6.2.5 How Standards Connect to Cable Designs</h3>

        <p>This is the critical integration point. When the Playground configures a machine step, tests are fetched and filtered by the design&rsquo;s standard category:</p>

        <pre><span class="comment"># In db_integration.py &mdash; fetches tests matching the design's standard</span>
<span class="keyword">def</span> get_tests_by_standard(db, standard):
    <span class="comment"># Maps frontend code to database category</span>
    category_map = {<span class="string">'EN'</span>: <span class="string">'IEC-EN'</span>, <span class="string">'UL'</span>: <span class="string">'UL'</span>, <span class="string">'SLN'</span>: <span class="string">'SLN'</span>}
    category = category_map.get(standard, standard)

    standards = db.query(TestStandard).filter(
        TestStandard.standard_category == category,
        TestStandard.is_active == <span class="keyword">True</span>
    ).all()
    <span class="keyword">return</span> [{<span class="string">'id'</span>: s.id, <span class="string">'test_name'</span>: s.test_name, ...} <span class="keyword">for</span> s <span class="keyword">in</span> standards]</pre>

        <p>When a design is finalized, the assigned tests are stored as a JSON array in <code>cable_database.test_requirements</code>:</p>

        <pre><span class="comment"># Storage format in cable_database.test_requirements</span>
[
  {
    <span class="string">"step"</span>: 3,
    <span class="string">"machine_type"</span>: <span class="string">"extruder"</span>,
    <span class="string">"test_id"</span>: 12,
    <span class="string">"test_name"</span>: <span class="string">"&Ccedil;ekme Dayan&#305;m&#305;"</span>,
    <span class="string">"standard_number"</span>: <span class="string">"EN 50618"</span>,
    <span class="string">"frequency"</span>: <span class="string">"her_ikisi"</span>
  }
]</pre>

        <div class="finding">
            <p style="margin-bottom: 0;"><strong>Denormalized by design:</strong> Test names and standard numbers are copied into the Cable Database JSON, not just referenced by ID. This means if a test standard is later renamed or deactivated, existing cable designs retain their original test requirements. The Lab reads from Cable Database at production time &mdash; it never needs to query the Standards table to know what to test.</p>
        </div>

        <h3>6.2.6 Permission Model</h3>

        <table>
            <tr><th>Action</th><th>Legacy Roles</th><th>Granular Permission</th></tr>
            <tr><td>View / List / Search</td><td>Any authenticated user</td><td>Any authenticated user</td></tr>
            <tr><td>Create / Update</td><td>super_admin, lab_user, production_manager</td><td><code>teknik.standards.create</code> / <code>teknik.standards.edit</code></td></tr>
            <tr><td>Delete</td><td>super_admin, lab_user</td><td><code>teknik.standards.delete</code></td></tr>
            <tr><td>Create / Update Results</td><td>lab_user, super_admin</td><td><code>teknik.standards.create</code></td></tr>
        </table>

        <p>Note: <code>lab_user</code> has wider access here than in Machine Management &mdash; this is intentional because lab personnel are the primary users of the standards system.</p>

        <h3>6.2.7 Frontend &mdash; Standards Page</h3>

        <p>Single file: <code>pages/Teknik/Standards/index.tsx</code> (553 lines). Route: <code>/teknik/standards</code>.</p>

        <h4>Page Structure</h4>
        <p><code>PageContainer</code> with a <code>ProTable</code> and a modal for create/edit. No tabs &mdash; all standards shown in one table, category distinguished by color-coded tags.</p>

        <h4>Table Columns (9)</h4>
        <table>
            <tr><th>Column</th><th>Width</th><th>Notes</th></tr>
            <tr><td>ID</td><td>60px</td><td>Fixed left</td></tr>
            <tr><td>Kategori</td><td>100px</td><td>Color-coded tag: <span class="good">IEC-EN</span> blue, <span class="good">UL</span> green, <span style="color:#f59e0b;font-weight:700;">SLN</span> orange</td></tr>
            <tr><td>Test Ad&#305;</td><td>auto</td><td>Turkish test name, ellipsis</td></tr>
            <tr><td>Standart No</td><td>150px</td><td>e.g. &ldquo;EN 50618&rdquo;</td></tr>
            <tr><td>Test Tipi</td><td>120px</td><td>Shows &ldquo;-&rdquo; if empty</td></tr>
            <tr><td>Numune Say&#305;s&#305;</td><td>100px</td><td>Centered integer</td></tr>
            <tr><td>Parametre</td><td>100px</td><td>Shows parameter count (e.g. &ldquo;3&rdquo;)</td></tr>
            <tr><td>Durum</td><td>80px</td><td>Green &ldquo;Aktif&rdquo; / Red &ldquo;Pasif&rdquo;</td></tr>
            <tr><td>&#304;&scedil;lemler</td><td>100px</td><td>Fixed right; edit + delete icons</td></tr>
        </table>

        <h4>Create/Edit Modal (800px, blurred backdrop)</h4>
        <p>The modal contains 7 form fields plus a dynamic parameter list:</p>
        <table>
            <tr><th>Field</th><th>Type</th><th>Required</th><th>Notes</th></tr>
            <tr><td>Standart Kategorisi</td><td>Select</td><td>Yes</td><td>Options: IEC-EN, UL, SLN (&Ouml;zel)</td></tr>
            <tr><td>Test Ad&#305; (TR)</td><td>Input</td><td>Yes</td><td>Placeholder: &ldquo;&Ouml;rn: &Ccedil;ekme Dayan&#305;m&#305;&rdquo;</td></tr>
            <tr><td>Test Ad&#305; (EN)</td><td>Input</td><td>No</td><td>Placeholder: &ldquo;&Ouml;rn: Tensile Strength&rdquo;</td></tr>
            <tr><td>Standart Numaras&#305;</td><td>Input</td><td>Yes</td><td>Placeholder: &ldquo;&Ouml;rn: EN 50618&rdquo;</td></tr>
            <tr><td>Test Tipi</td><td>Select</td><td>No</td><td>Options: Mekanik, Elektriksel, G&ouml;rsel, Boyutsal</td></tr>
            <tr><td>Numune Say&#305;s&#305;</td><td>InputNumber</td><td>No</td><td>Min: 1</td></tr>
            <tr><td>Test Metodu</td><td>TextArea</td><td>No</td><td>3 rows, procedure description</td></tr>
        </table>

        <h4>Parameter Management (inside modal)</h4>
        <p>Below a &ldquo;Test Parametreleri&rdquo; divider, each parameter is rendered as a small Card with two fields:</p>
        <ul>
            <li><strong>Parametre Ad&#305;</strong> &mdash; Input, placeholder &ldquo;Parametre Ad&#305; (&ouml;rn: &Ccedil;ekme Dayan&#305;m&#305;, Uzama, Diren&ccedil;)&rdquo;</li>
            <li><strong>Birim</strong> &mdash; Input, placeholder &ldquo;Birim (&ouml;rn: N/mm&sup2;, %, ohm/km)&rdquo;</li>
        </ul>
        <p>&ldquo;Parametre Ekle&rdquo; button (dashed, full-width) adds a new empty parameter card. Each card has a delete button in the header. Order is auto-assigned sequentially. On update, all existing parameters are <strong>replaced</strong> with the new set (delete all + create new).</p>

        <h4>CRUD Flow</h4>

        <p><strong>Create:</strong> Click &ldquo;Yeni Test Standard&#305;&rdquo; &rarr; Modal opens &rarr; Fill category, name, standard number &rarr; Optionally add parameters &rarr; Click &ldquo;Ekle&rdquo; &rarr; <code>POST /api/teknik/standards/tests</code> &rarr; Toast &ldquo;Test standard&#305; ba&scedil;ar&#305;yla eklendi!&rdquo; &rarr; Modal closes, list refreshes.</p>

        <p><strong>Edit:</strong> Click edit icon &rarr; Modal opens pre-filled &rarr; Modify fields/parameters &rarr; Click &ldquo;G&uuml;ncelle&rdquo; &rarr; <code>PUT /api/teknik/standards/tests/{id}</code> &rarr; Toast &ldquo;Test standard&#305; ba&scedil;ar&#305;yla g&uuml;ncellendi!&rdquo; &rarr; Modal closes, list refreshes.</p>

        <p><strong>Delete:</strong> Click delete icon &rarr; Popconfirm &ldquo;Bu standard&#305; devre d&#305;&scedil;&#305; b&#305;rakmak istedi&#287;inize emin misiniz?&rdquo; &rarr; <code>DELETE /api/teknik/standards/tests/{id}</code> &rarr; Toast &ldquo;Test standard&#305; devre d&#305;&scedil;&#305; b&#305;rak&#305;ld&#305;!&rdquo; &rarr; List refreshes. Delete button disabled for already-inactive standards.</p>

        <h4>Search &amp; Pagination</h4>
        <p><strong>Search</strong> is client-side (200px rounded input). Searches across ID, category, test name, standard number, test type, sample count, and status (aktif/pasif). <strong>Pagination</strong> defaults to 10 rows with [10, 20, 50, 100] options. Sorted by ID descending (newest first).</p>

        <h3>6.2.8 How It Connects to Other Submodules</h3>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>&rarr; Cable Playground (6.5)</h4>
                <p>Every machine form in the Playground includes an <code>available_tests</code> section populated via <code>get_tests_by_standard()</code>. Users assign tests to steps with a frequency. The Playground&rsquo;s form integration reads from Standards but never writes to it.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Cable Database (6.6)</h4>
                <p>Finalized designs store <code>test_requirements</code> as denormalized JSON &mdash; test IDs, names, standard numbers, and frequencies copied at finalization time. This snapshot ensures immutability.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Lab Module</h4>
                <p>During production, the Lab reads test requirements from Cable Database and creates <code>TestResult</code> records linked to the standard. Lab users fill measurements and set pass/fail status with timestamped notes for audit trail.</p>
            </div>
        </div>

        <div class="discovery">
            <p style="margin-bottom: 0;"><strong>Design principle:</strong> Standards are defined once, embedded into designs by value (not by reference), and tested during production. The three-table structure (standard &rarr; parameters &rarr; results) separates definition from execution. Standards Management never touches production data &mdash; it only answers &ldquo;what should be tested?&rdquo;, leaving &ldquo;what was the result?&rdquo; to the Lab module.</p>
        </div>

        <!-- ============================================ -->
        <h2>6.3 OPERATOR MANAGEMENT</h2>
        <!-- ============================================ -->

        <p>Production operators are the people running the machines on the factory floor. They don&rsquo;t need system logins &mdash; they are simply names in a registry that get assigned to production sessions when someone starts a manufacturing run. This is the simplest submodule in Teknik (284 lines of frontend, 4 endpoints), but its data appears in every production session, every work card, and every half-product record.</p>

        <div class="insight">
            <p style="margin-bottom: 0;"><strong>Two kinds of &ldquo;operator&rdquo; in the system:</strong> <code>ProductionOperator</code> (this submodule) is a simple name registry &mdash; no login, no password, no permissions. The separate <code>Operator</code> model in the User system extends user accounts for operator-type users who log into the system. When an operator starts a production session, they select their own name from the <code>ProductionOperator</code> registry. The work card they&rsquo;re producing was planned earlier by a production manager via the planning module.</p>
        </div>

        <h3>6.3.1 Database Schema</h3>

        <h4><code>production_operators</code></h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Nullable</th><th>Constraints / Default</th><th>Notes</th></tr>
            <tr><td><code>id</code></td><td>Integer</td><td>No</td><td>PK, indexed</td><td>&mdash;</td></tr>
            <tr><td><code>name</code></td><td>String(100)</td><td>No</td><td><strong>UNIQUE</strong></td><td>Operator&rsquo;s full name</td></tr>
            <tr><td><code>is_active</code></td><td>Boolean</td><td>No</td><td>Default: True</td><td>Active status flag</td></tr>
            <tr><td><code>created_at</code></td><td>DateTime</td><td>No</td><td>utcnow</td><td>&mdash;</td></tr>
            <tr><td><code>updated_at</code></td><td>DateTime</td><td>No</td><td>utcnow, auto-updates</td><td>&mdash;</td></tr>
        </table>

        <p>That&rsquo;s the entire table. Five columns. No foreign keys, no relationships, no JSON blobs. The <code>UNIQUE</code> constraint on <code>name</code> is the only business rule &mdash; you can&rsquo;t have two operators with the same name.</p>

        <div class="finding">
            <p style="margin-bottom: 0;"><strong>No relationships defined.</strong> The <code>ProductionOperator</code> model has zero SQLAlchemy relationships. Production sessions reference operators by storing the <code>operator_name</code> as a denormalized string &mdash; not a foreign key. This means deleting an operator doesn&rsquo;t cascade to sessions, but it also means old session records always retain the correct operator name even if the operator is later removed.</p>
        </div>

        <h3>6.3.2 API Endpoints</h3>

        <p>4 endpoints under <code>/operators</code>. Notably, there are <strong>no role checks</strong> beyond authentication &mdash; any logged-in user can manage operators. No Pydantic schemas either; the routes accept and return raw dictionaries.</p>

        <table>
            <tr><th>Method</th><th>Path</th><th>Permission</th><th>What It Does</th></tr>
            <tr><td><code>GET</code></td><td><code>/operators/list</code></td><td>Authenticated</td><td>List all operators. <code>?active_only=true</code> (default). Ordered by name ascending. Returns array + total count.</td></tr>
            <tr><td><code>POST</code></td><td><code>/operators/create</code></td><td>Authenticated</td><td>Create operator. Trims name, checks empty, checks duplicate. Sets <code>is_active=true</code>.</td></tr>
            <tr><td><code>PUT</code></td><td><code>/operators/{id}</code></td><td>Authenticated</td><td>Update operator name. Checks exists, checks empty, checks duplicate (excluding self).</td></tr>
            <tr><td><code>DELETE</code></td><td><code>/operators/{id}</code></td><td>Authenticated</td><td><strong>Hard delete.</strong> No cascade check. May fail if referenced by production sessions.</td></tr>
        </table>

        <h4>Validation Details</h4>
        <table>
            <tr><th>Check</th><th>When</th><th>Error Message (Turkish)</th></tr>
            <tr><td>Name empty</td><td>Create / Update</td><td>&ldquo;Operat&ouml;r ad&#305; gerekli&rdquo;</td></tr>
            <tr><td>Name duplicate</td><td>Create</td><td>&ldquo;&lsquo;{name}&rsquo; ad&#305;nda operat&ouml;r zaten mevcut&rdquo;</td></tr>
            <tr><td>Name duplicate (excl. self)</td><td>Update</td><td>&ldquo;&lsquo;{name}&rsquo; ad&#305;nda ba&scedil;ka operat&ouml;r zaten mevcut&rdquo;</td></tr>
            <tr><td>Not found</td><td>Update / Delete</td><td>&ldquo;Operat&ouml;r bulunamad&#305;&rdquo;</td></tr>
        </table>

        <h3>6.3.3 How Operators Are Used in Production</h3>

        <p>This is where the simple name registry becomes critical. When a production session starts, the operator is assigned and their name is stored directly in the session record:</p>

        <pre><span class="comment"># In production_routes.py â€” starting a production session</span>
<span class="keyword">if</span> request.operator_id:
    prod_operator = db.query(ProductionOperator).filter(
        ProductionOperator.id == request.operator_id
    ).first()
    <span class="keyword">if</span> prod_operator:
        operator_name = prod_operator.name

<span class="comment"># Stored in production_sessions table:</span>
<span class="comment"># operator_id  â†’ current_user.id (FK to users, for DB integrity)</span>
<span class="comment"># operator_name â†’ prod_operator.name (denormalized, for history)</span></pre>

        <h4>The Dual Storage Pattern</h4>

        <p>Production sessions store operator information in two ways:</p>
        <table>
            <tr><th>Column</th><th>Points To</th><th>Purpose</th></tr>
            <tr><td><code>operator_id</code></td><td>FK &rarr; <code>users.id</code></td><td>Database integrity (the <em>user</em> who started the session)</td></tr>
            <tr><td><code>operator_name</code></td><td>String (denormalized)</td><td>The <em>production operator</em> running the machine (from this registry)</td></tr>
        </table>

        <p>This separation exists because the system tracks both <em>who</em> is logged in (the user account, stored as <code>operator_id</code> FK) and <em>which production operator</em> is physically running the machine (the name from this registry, stored as <code>operator_name</code>). The operator selects their own name from a dropdown when starting a production session for a work card that was pre-planned by the production manager.</p>

        <h4>Operator in the Production Lifecycle</h4>

        <div class="flow">
            <div class="flow-box" style="background: #faf5ff; border-color: #7c3aed;">Registry<br><span style="font-size:9px;color:#666;">Names defined here</span></div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box" style="background: #eff6ff; border-color: #2563eb;">Session Start<br><span style="font-size:9px;color:#666;">Select operator</span></div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box" style="background: #dcfce7; border-color: #16a34a;">Production<br><span style="font-size:9px;color:#666;">Name stored in session</span></div>
            <span class="flow-arrow">&rarr;</span>
            <div class="flow-box" style="background: #fffbe6; border-color: #f59e0b;">History<br><span style="font-size:9px;color:#666;">Preserved forever</span></div>
        </div>

        <ul>
            <li><strong>Session Start:</strong> Production page fetches operators with <code>GET /operators/list?active_only=true</code>. The operator selects their own name from the dropdown before starting a pre-planned work card. Required to start.</li>
            <li><strong>Mid-Session Change:</strong> Operators can be swapped during a session via <code>POST /production/update-operator</code> &mdash; useful for shift changes.</li>
            <li><strong>Half-Product Tracking:</strong> Stock pages enrich half-product records with <code>operator_name</code> from the production session that created them.</li>
            <li><strong>History:</strong> Production history pages show operator name for every completed session.</li>
        </ul>

        <h3>6.3.4 Frontend &mdash; Operator Page</h3>

        <p>Single file: <code>pages/Teknik/OperatorYonetimi/index.tsx</code> (284 lines). Route: <code>/teknik/operator-yonetimi</code>. The smallest page in the entire Teknik module.</p>

        <h4>Table Columns (3)</h4>
        <table>
            <tr><th>Column</th><th>Width</th><th>Notes</th></tr>
            <tr><td>ID</td><td>80px</td><td>Fixed left</td></tr>
            <tr><td>Operat&ouml;r Ad&#305;</td><td>auto</td><td>Ellipsis enabled</td></tr>
            <tr><td>&#304;&scedil;lemler</td><td>100px</td><td>Fixed right; edit + delete icons</td></tr>
        </table>

        <p>No status column, no timestamps. Just the name. The <code>is_active</code> and <code>created_at</code>/<code>updated_at</code> fields exist in the data interface but are not displayed.</p>

        <h4>Create/Edit Modal (400px, blurred backdrop)</h4>
        <p>One field:</p>
        <table>
            <tr><th>Field</th><th>Type</th><th>Required</th><th>Notes</th></tr>
            <tr><td>Operat&ouml;r Ad&#305;</td><td>Input (large)</td><td>Yes</td><td>Placeholder: &ldquo;Operat&ouml;r ad&#305;n&#305; girin&rdquo;</td></tr>
        </table>

        <h4>CRUD Flow</h4>
        <p><strong>Create:</strong> Click &ldquo;Yeni Operat&ouml;r&rdquo; &rarr; Modal (400px) &rarr; Enter name &rarr; Click &ldquo;Olu&scedil;tur&rdquo; &rarr; <code>POST /api/operators/create</code> &rarr; Toast &ldquo;Operat&ouml;r olu&scedil;turuldu&rdquo; &rarr; Modal closes, list refreshes.</p>
        <p><strong>Edit:</strong> Click edit icon &rarr; Modal pre-filled &rarr; Change name &rarr; Click &ldquo;G&uuml;ncelle&rdquo; &rarr; <code>PUT /api/operators/{id}</code> &rarr; Toast &ldquo;Operat&ouml;r g&uuml;ncellendi&rdquo; &rarr; Modal closes, list refreshes.</p>
        <p><strong>Delete:</strong> Click delete icon &rarr; Popconfirm &ldquo;Operat&ouml;r&uuml; silmek istedi&#287;inize emin misiniz?&rdquo; &rarr; <code>DELETE /api/operators/{id}</code> &rarr; Toast &ldquo;Operat&ouml;r silindi&rdquo; &rarr; List refreshes.</p>

        <h4>Search &amp; Pagination</h4>
        <p><strong>Search</strong> is client-side (200px input). Filters by name and ID (case-insensitive). <strong>Pagination</strong> defaults to 20 rows (higher than other pages, since the operator list is short), with [10, 20, 50, 100] options.</p>

        <h4>How Operators Appear in Production Pages</h4>
        <p>Production pages (Kabatel&Ccedil;ekme, Kalaylama, etc.) show operator selection in two states:</p>
        <ul>
            <li><strong>Before session:</strong> A <code>Select</code> dropdown with <code>UserOutlined</code> icon, placeholder &ldquo;Operat&ouml;r se&ccedil;in&rdquo;, populated from <code>GET /operators/list?active_only=true</code>. Required to enable the &ldquo;&Uuml;retime Ba&scedil;la&rdquo; button.</li>
            <li><strong>During session:</strong> A card showing the current operator name with a &ldquo;De&#287;i&scedil;tir&rdquo; button that opens a modal listing all operators as clickable cards for mid-session changes.</li>
        </ul>

        <h3>6.3.5 How It Connects to Other Submodules</h3>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>&rarr; &Uuml;retim (Production Module)</h4>
                <p>Primary consumer. Every production session requires an operator. The name is stored denormalized in the session record. Operators can be changed mid-session for shift handoffs. Production history displays operator per session.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Stok (Stock Module)</h4>
                <p>Half-product records trace back to the production session that created them. Stock pages resolve <code>session.operator_name</code> to show which operator produced each item &mdash; full production traceability.</p>
            </div>
        </div>

        <div class="discovery">
            <p style="margin-bottom: 0;"><strong>Design principle:</strong> Radical simplicity. One table, one field that matters (name), four endpoints, no role checks beyond authentication. The complexity lives in how production consumes this data &mdash; the dual storage pattern (FK for integrity, name for history) is the clever part. An operator&rsquo;s name is entered once into the registry, and from then on they simply pick it from a dropdown each time they start a production session &mdash; that name then follows every meter of cable they produce.</p>
        </div>


        <!-- ============================================ -->
        <!-- 6.4  MARKALAMA (CABLE MARKING)               -->
        <!-- ============================================ -->

        <h2 id="markalama">6.4 Markalama (Cable Marking)</h2>

        <p>Every meter of cable that leaves the factory has text physically printed on its sheath &mdash; company name, standard, voltage rating, cross-section, production year. Markalama is the submodule that manages these <strong>marking templates</strong>: ordered arrays of words/segments that the extruder machine prints during cable production.</p>

        <div class="insight">
            <p style="margin-bottom: 0;"><strong>What a marking template is:</strong> Not a single string, but an <strong>ordered JSON array</strong> of words. Each word is printed sequentially on the cable during extrusion, repeating along the cable&rsquo;s entire length. Words can include <strong>dynamic variables</strong> (<code>{CABLE_SIZE}</code>, <code>{ORDER_NO}</code>, <code>{YEAR}</code>, <code>{METER}</code>) that are resolved at production time. Example: <code>["SOLEN BEAM", "TUV RHEINLAND", "H07V-K", "{CABLE_SIZE}", "{YEAR}"]</code> &rarr; prints <code>SOLEN BEAM &middot; TUV RHEINLAND &middot; H07V-K &middot; 4mm&sup2; &middot; 2025</code> repeating along the cable.</p>
        </div>

        <h3>6.4.1 Database Schema</h3>

        <p>One table. Minimal design.</p>

        <table>
            <tr><th>Column</th><th>Type</th><th>Constraints</th><th>Purpose</th></tr>
            <tr><td><code>id</code></td><td><code>Integer</code></td><td>PK, auto-increment, indexed</td><td>Unique identifier</td></tr>
            <tr><td><code>name</code></td><td><code>String(200)</code></td><td><strong>UNIQUE</strong>, NOT NULL, indexed</td><td>Template name (e.g. &ldquo;SOLEN BEAM Standard&rdquo;)</td></tr>
            <tr><td><code>words</code></td><td><code>JSON</code></td><td>NOT NULL</td><td>Ordered array of strings &mdash; the words printed on the cable</td></tr>
            <tr><td><code>is_active</code></td><td><code>Boolean</code></td><td>NOT NULL, default <code>true</code></td><td>Soft delete flag. Inactive markings hidden from order dropdowns.</td></tr>
            <tr><td><code>created_at</code></td><td><code>DateTime(tz)</code></td><td>server default <code>now()</code></td><td>Creation timestamp</td></tr>
            <tr><td><code>updated_at</code></td><td><code>DateTime(tz)</code></td><td>on update <code>now()</code></td><td>Last modification timestamp</td></tr>
        </table>

        <div class="finding">
            <p style="margin-bottom: 0;"><strong>JSON storage for words:</strong> The <code>words</code> column stores a JSON array (e.g. <code>["SOLEN BEAM", "TUV RHEINLAND", "H07V-K"]</code>). The backend handles both native JSON and string-encoded JSON &mdash; the list endpoint explicitly parses: <code>json.loads(m.words) if isinstance(m.words, str) else m.words</code>. This dual handling ensures robustness regardless of how the database driver serializes the column.</p>
        </div>

        <h4>Key Constraints</h4>
        <ul>
            <li><strong>UNIQUE name:</strong> No two marking templates can share the same name. Enforced at both database level (unique index) and application level (duplicate check before create/update).</li>
            <li><strong>No foreign keys:</strong> The <code>markings</code> table has no FKs. Instead, <code>order_cables.marking_id</code> in the Sipari&scedil; module references this table. The relationship is consumer-side, not defined here.</li>
        </ul>

        <h3>6.4.2 API Endpoints</h3>

        <p>Six endpoints under <code>/api/teknik/markings</code>:</p>

        <table>
            <tr><th>Method</th><th>Path</th><th>Permission</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/markings/create</code></td><td>super_admin + <code>teknik.markalama.create_marking</code></td><td>Create template. Checks duplicate name. Stores <code>name</code> + <code>words</code> array.</td></tr>
            <tr><td><code>GET</code></td><td><code>/markings/list</code></td><td>Authenticated</td><td>List all. <code>?active_only=true</code> (default), <code>?search=solen</code> (name ilike). Ordered by name. Parses JSON words.</td></tr>
            <tr><td><code>GET</code></td><td><code>/markings/{id}</code></td><td>Authenticated</td><td>Single marking by ID.</td></tr>
            <tr><td><code>PUT</code></td><td><code>/markings/{id}</code></td><td>super_admin + <code>teknik.markalama.update_marking</code></td><td>Partial update. If name changes, checks for conflicts. Only provided fields are modified.</td></tr>
            <tr><td><code>DELETE</code></td><td><code>/markings/{id}/hard-delete</code></td><td>super_admin + <code>teknik.markalama.delete_marking</code></td><td>Permanent delete. No soft delete on this endpoint.</td></tr>
            <tr><td><code>PUT</code></td><td><code>/markings/{id}/toggle-status</code></td><td>Authenticated</td><td>Flip <code>is_active</code> between <code>true</code>/<code>false</code>. No permission check beyond auth.</td></tr>
        </table>

        <h4>Validation Details</h4>
        <table>
            <tr><th>Check</th><th>Where</th><th>Details</th></tr>
            <tr><td>Name required</td><td>Schema (<code>min_length=1</code>)</td><td>Pydantic rejects empty strings</td></tr>
            <tr><td>Name max length</td><td>Schema + DB</td><td><code>max_length=200</code> in Pydantic, <code>String(200)</code> in SQLAlchemy</td></tr>
            <tr><td>Words non-empty</td><td>Schema validator</td><td>Custom <code>@validator('words')</code> ensures <code>len(v) &gt; 0</code></td></tr>
            <tr><td>Duplicate name</td><td>Route handler</td><td>Queries DB before create. On update, excludes self (<code>Marking.id != marking_id</code>)</td></tr>
            <tr><td>Exists check</td><td>Route handler</td><td>404 if marking not found on get/update/delete</td></tr>
        </table>

        <h4>Delete Behavior</h4>
        <p>The delete endpoint is <strong>hard delete</strong> (<code>db.delete(marking)</code>). Unlike Standards Management, there is no smart delete logic. If a marking is referenced by existing orders, those orders retain the <code>marking_id</code> integer but the marking record is gone. The safer workflow is to <strong>toggle status to inactive</strong> using the <code>/toggle-status</code> endpoint, which hides the marking from new orders while keeping the record intact for historical lookups.</p>

        <h3>6.4.3 Pydantic Schemas</h3>

        <table>
            <tr><th>Schema</th><th>Fields</th><th>Used By</th></tr>
            <tr><td><code>MarkingCreateRequest</code></td><td><code>name: str</code>, <code>words: List[str]</code> (min 1 item)</td><td>POST create</td></tr>
            <tr><td><code>MarkingUpdateRequest</code></td><td><code>name?: str</code>, <code>words?: List[str]</code>, <code>is_active?: bool</code></td><td>PUT update (all optional for partial)</td></tr>
            <tr><td><code>MarkingResponse</code></td><td><code>id, name, words, is_active, created_at, updated_at</code></td><td>All responses</td></tr>
            <tr><td><code>MarkingListResponse</code></td><td><code>success: bool</code>, <code>data: List[MarkingResponse]</code>, <code>message: str</code></td><td>Defined but not used (list returns raw array)</td></tr>
        </table>

        <div class="finding">
            <p style="margin-bottom: 0;"><strong>Unused wrapper:</strong> <code>MarkingListResponse</code> is defined in schemas but the <code>/list</code> endpoint returns a raw array, not the wrapper. The endpoint manually constructs dictionaries with parsed JSON words instead of using the Pydantic <code>response_model</code>. This is a pragmatic choice to handle the JSON string/native dual format.</p>
        </div>

        <h3>6.4.4 Dynamic Variables</h3>

        <p>Marking words support four runtime variables that get resolved during production:</p>

        <table>
            <tr><th>Variable</th><th>Resolves To</th><th>Example</th></tr>
            <tr><td><code>{CABLE_SIZE}</code></td><td>Cable cross-section from order</td><td><code>4mm&sup2;</code></td></tr>
            <tr><td><code>{ORDER_NO}</code></td><td>Order number</td><td><code>SLN-2025-0042</code></td></tr>
            <tr><td><code>{YEAR}</code></td><td>Production year</td><td><code>2025</code></td></tr>
            <tr><td><code>{METER}</code></td><td>Running meter mark on cable</td><td><code>150</code></td></tr>
        </table>

        <p>Variable resolution happens at the production/extrusion layer, not in this submodule. Markalama just stores the templates with placeholder syntax. The frontend displays these as helper text in the form: <em>&ldquo;De&gbreve;i&scedil;kenler: {CABLE_SIZE}, {ORDER_NO}, {YEAR}, {METER}&rdquo;</em>.</p>

        <h3>6.4.5 Permission Model</h3>

        <table>
            <tr><th>Action</th><th>Role Check</th><th>Permission Key</th></tr>
            <tr><td>View / List / Search</td><td>Any authenticated user</td><td>Any authenticated user</td></tr>
            <tr><td>Create</td><td>super_admin</td><td><code>teknik.markalama.create_marking</code></td></tr>
            <tr><td>Update</td><td>super_admin</td><td><code>teknik.markalama.update_marking</code></td></tr>
            <tr><td>Delete</td><td>super_admin</td><td><code>teknik.markalama.delete_marking</code></td></tr>
            <tr><td>Toggle Status</td><td>Any authenticated user</td><td>No additional check</td></tr>
        </table>

        <p>Unlike Machines (which allow <code>production_manager</code>) or Standards (which allow <code>lab_user</code>), Markalama write operations are restricted to <code>super_admin</code> only. The <code>check_permission_smart</code> function validates both the role and the granular permission key. The toggle-status endpoint is an exception &mdash; any authenticated user can activate/deactivate a marking.</p>

        <h4>Permission Manifest (Frontend)</h4>
        <p>The frontend permission system defines 5 buttons for the Markalama page:</p>
        <ul>
            <li><code>access_page</code> &mdash; Can view the Markalama page</li>
            <li><code>view_markings</code> &mdash; Can see the marking list</li>
            <li><code>create_marking</code> &mdash; Can add new markings</li>
            <li><code>edit_marking</code> &mdash; Can edit existing markings</li>
            <li><code>delete_marking</code> &mdash; Can permanently delete markings (critical)</li>
        </ul>

        <h3>6.4.6 Frontend &mdash; Page Structure</h3>

        <p>Single file: <code>src/pages/Teknik/Markalama/index.tsx</code> (374 lines). Route: <code>/teknik/markalama</code>.</p>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>PageContainer</h4>
                <p>Ant Design Pro wrapper with title &ldquo;Markalama&rdquo;.</p>
            </div>
            <div class="arch-box">
                <h4>ProTable</h4>
                <p>Main data table. Fetches from <code>/api/teknik/markings/list</code> with <code>active_only=false</code> (shows all, including inactive). Client-side search and pagination.</p>
            </div>
            <div class="arch-box">
                <h4>Modal (700px)</h4>
                <p>Create/edit form. Contains name input + dynamic word list (Form.List). Blur-on-backdrop effect.</p>
            </div>
        </div>

        <h4>Table Columns (4)</h4>
        <table>
            <tr><th>#</th><th>Column</th><th>Width</th><th>Features</th></tr>
            <tr><td>1</td><td>&Idot;sim (Name)</td><td>250px</td><td>Fixed left. Sortable (localeCompare). Primary identifier.</td></tr>
            <tr><td>2</td><td>Kelime Say&inodot;s&inodot; (Word Count)</td><td>120px</td><td>Computed: parses <code>words</code> JSON/array, returns <code>.length</code>. Not the words themselves.</td></tr>
            <tr><td>3</td><td>Durum (Status)</td><td>100px</td><td>Green <code>&lt;Tag&gt;</code> for Aktif, red for Pasif.</td></tr>
            <tr><td>4</td><td>&Idot;&scedil;lemler (Actions)</td><td>100px</td><td>Fixed right. Edit button + Delete with Popconfirm (&ldquo;Are you sure?&rdquo;).</td></tr>
        </table>

        <h4>Create/Edit Modal</h4>
        <p>The modal has two form sections:</p>

        <p><strong>1. Name Field</strong></p>
        <ul>
            <li><code>&lt;Input&gt;</code> with placeholder &ldquo;&ouml;r: SOLEN BEAM Standard&rdquo;</li>
            <li>Required validation</li>
        </ul>

        <p><strong>2. Words (Dynamic List)</strong></p>
        <ul>
            <li>Uses Ant Design <code>&lt;Form.List&gt;</code> for dynamic add/remove</li>
            <li>Each word is a numbered row: <code>1.</code>, <code>2.</code>, <code>3.</code>&hellip; with a 550px-wide input</li>
            <li>Minimum 1 word enforced by custom validator</li>
            <li>Red <code>&lt;MinusCircleOutlined&gt;</code> to remove a word (hidden when only 1 word remains)</li>
            <li>Dashed &ldquo;Kelime Ekle&rdquo; (Add Word) button at bottom to append new rows</li>
            <li>On create, starts with one empty word slot</li>
            <li>On edit, pre-populates all existing words</li>
            <li>Variable hint text shown in the label: <em>&ldquo;De&gbreve;i&scedil;kenler: {CABLE_SIZE}, {ORDER_NO}, {YEAR}, {METER}&rdquo;</em></li>
        </ul>

        <h4>CRUD Flow</h4>

        <div class="flow">
            <span class="flow-step">Click &ldquo;Yeni Markalama&rdquo;</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Modal opens (1 empty word slot)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Enter name + add words</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">POST /markings/create</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Table refreshes (key increment)</span>
        </div>

        <div class="flow" style="margin-top: 12px;">
            <span class="flow-step">Click edit icon</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Modal opens (pre-filled)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Modify name/words</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">PUT /markings/{id}</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Table refreshes</span>
        </div>

        <div class="flow" style="margin-top: 12px;">
            <span class="flow-step">Click delete icon</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Popconfirm dialog</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">DELETE /markings/{id}/hard-delete</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Table refreshes</span>
        </div>

        <h4>Search &amp; Pagination</h4>
        <p><strong>Search</strong> is client-side (200px rounded input). Filters on name, status text (aktif/pasif), and word count number. <strong>Pagination</strong> defaults to 10 rows, options [10, 20, 50, 100]. Shows &ldquo;X-Y / Z kay&inodot;t&rdquo; total.</p>

        <h3>6.4.7 How Markings Flow Through the System</h3>

        <p>Markalama templates are <strong>reference data</strong>. They are created once in the Teknik module and then consumed at two critical points in the order-to-production pipeline:</p>

        <h4>Step 1: Order Creation (Sipari&scedil; Module)</h4>

        <div class="flow">
            <span class="flow-step">Order creation page loads</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">GET /markings/list?active_only=true</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Populate marking dropdown per cable</span>
        </div>

        <p>In the order creation form, each cable entry has a <strong>&ldquo;Markalama&rdquo; dropdown</strong> (searchable <code>&lt;Select&gt;</code>). It shows only active markings. The user picks one, and the <code>marking_id</code> is stored in <code>order_cables.marking_id</code> (integer FK). Marking selection is required for a cable to be considered &ldquo;complete&rdquo; in the order form.</p>

        <pre style="background: #f5f5f5; padding: 16px; border-radius: 8px; overflow-x: auto; font-size: 13px;">
<span style="color: #666;">// Order form cable completion check (SiparisOlustur/index.tsx)</span>
const isComplete = hasDesign && hasMeters && hasMakara
  && <strong>hasMarking</strong> && hasPrice && hasCurrency && materialsComplete;</pre>

        <h4>Step 2: Work Card Generation &amp; Production Planning</h4>

        <p>When an order is confirmed and work cards are generated:</p>

        <div class="flow">
            <span class="flow-step">Order confirmed</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Work card generator reads cable data</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Resolves marking_id &rarr; marking_name</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Stores both in extruder material_details</span>
        </div>

        <p>The <code>work_card_generator.py</code> service resolves each cable&rsquo;s <code>marking_id</code> to the actual marking name by querying the Marking table. Both <code>marking_id</code> and <code>marking_name</code> are embedded in the extruder work card&rsquo;s <code>material_details</code> JSON:</p>

        <pre style="background: #f5f5f5; padding: 16px; border-radius: 8px; overflow-x: auto; font-size: 13px;">
<span style="color: #666;"># work_card_generator.py &mdash; extruder material_details</span>
{
    'marking_id': cable_data.get('marking_id'),    <span style="color: #666;"># Integer FK</span>
    'marking_name': cable_data.get('marking_name'), <span style="color: #666;"># Resolved text</span>
    'tests': ex_tests,
    'breakdown': [],
    ...
}</pre>

        <h4>Step 3: Production Planning Display</h4>

        <p>The Production Planning page reads the extruder work card&rsquo;s <code>material_details</code> and displays the marking name in the card UI:</p>

        <pre style="background: #f5f5f5; padding: 16px; border-radius: 8px; overflow-x: auto; font-size: 13px;">
<span style="color: #666;">// Production/Planning/index.tsx</span>
{materialDetails.marking_name && (
  &lt;div&gt;
    &lt;div style={{ fontSize: 10, fontWeight: 600 }}&gt;Markalama&lt;/div&gt;
    &lt;div style={{ fontSize: 11 }}&gt;{materialDetails.marking_name}&lt;/div&gt;
  &lt;/div&gt;
)}</pre>

        <h4>Step 4: Order Detail View</h4>

        <p>When viewing an existing order, the detail page shows the marking. The <code>order_routes.py</code> endpoint resolves <code>marking_id</code> to the name at query time:</p>

        <pre style="background: #f5f5f5; padding: 16px; border-radius: 8px; overflow-x: auto; font-size: 13px;">
<span style="color: #666;"># order_routes.py &mdash; marking resolution</span>
marking_name = None
if cable.marking_id:
    marking = db.query(Marking).filter(Marking.id == cable.marking_id).first()
    marking_name = marking.name if marking else None</pre>

        <p>This pattern appears twice in <code>order_routes.py</code>: once for the single order detail endpoint, and once for the work card generation data extraction.</p>

        <h3>6.4.8 Data Storage Pattern &mdash; ID vs Name</h3>

        <div class="insight">
            <p style="margin-bottom: 0;"><strong>Dual storage in consumption:</strong> Like the Operator dual storage pattern (6.3), markings use a hybrid approach &mdash; but split across different storage locations. The <code>order_cables</code> table stores only <code>marking_id</code> (integer). The work card <code>material_details</code> JSON stores both <code>marking_id</code> and <code>marking_name</code> (denormalized). This means order detail views must query the Marking table at runtime, but production planning can display the name directly from the JSON without an extra join.</p>
        </div>

        <h3>6.4.9 Connections to Other Submodules</h3>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>&rarr; Sipari&scedil; (Order Module)</h4>
                <p>Primary consumer. Every cable in an order has a <code>marking_id</code> FK pointing to the <code>markings</code> table. The order creation page fetches active markings as a searchable dropdown. Marking is required for cable completion.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; &Uuml;retim Planlama (Production Planning)</h4>
                <p>The work card generator resolves marking names and embeds them in extruder work card material_details. Production planning displays the marking name on extruder cards so operators know what text to verify on the cable.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Sipari&scedil; Detay (Order Detail View)</h4>
                <p>Order detail pages resolve <code>marking_id</code> to <code>marking_name</code> at query time. Displayed as a <code>ValueDisplay</code> component showing the template name.</p>
            </div>
        </div>

        <div class="discovery">
            <p style="margin-bottom: 0;"><strong>Design principle:</strong> Template-based marking. Rather than storing free-text marking instructions per order, the system maintains a registry of reusable templates. This ensures consistency &mdash; every order for the same cable type uses the exact same marking text. The ordered word array structure maps directly to how the extruder printing head works: it cycles through the words sequentially, printing each segment with spacing between them along the cable&rsquo;s length. Dynamic variables (<code>{CABLE_SIZE}</code>, <code>{YEAR}</code>, etc.) add order-specific context without creating new templates.</p>
        </div>


        <!-- ============================================ -->
        <!-- 6.5  KABLO TASARIM (CABLE PLAYGROUND)        -->
        <!--   +  6.6  KABLO VER&Idot;TABANI (CABLE DATABASE)    -->
        <!-- ============================================ -->

        <h2 id="playground">6.5 &amp; 6.6 Kablo Tasar&inodot;m (Cable Playground) &amp; Kablo Veritaban&inodot; (Cable Database)</h2>

        <p>These two submodules are documented together because they are inseparable: <strong>Playground</strong> is where cables are designed step-by-step using real factory machines, and <strong>Cable Database</strong> is the permanent repository where finalized designs are stored. Every other module in the system &mdash; Orders, Production Planning, Work Cards, Material Calculations, Stock &mdash; ultimately depends on the records that Playground creates and saves into Cable Database.</p>

        <div class="insight">
            <p style="margin-bottom: 0;"><strong>The convergence point:</strong> This is where every other Teknik submodule merges. Machine Management provides the machines and their capability ranges. Standards Management provides the tests to assign at each step. Operator Management provides the operators who will execute the design. Markalama provides the text printed during extrusion. Playground consumes all of this data to create a complete production blueprint, which gets saved to Cable Database as the single source of truth for the entire manufacturing pipeline.</p>
        </div>

        <h3>6.5.1 Core Concept &mdash; How Cable Design Works</h3>

        <p>Cable manufacturing follows a strict sequential pipeline. Raw copper (8mm filma&scedil;in) enters the first machine and is progressively transformed through 6 machine types until a finished cable emerges. The Playground simulates this entire process digitally.</p>

        <h4>The Six Machine Types (in order)</h4>
        <table>
            <tr><th>#</th><th>Machine</th><th>Input</th><th>Output</th><th>Key Parameters</th></tr>
            <tr><td>1</td><td><strong>Kabatel &Ccedil;ekme</strong></td><td>8mm filma&scedil;in (raw copper)</td><td>Drawn wire (e.g. 1.8mm)</td><td>output_diameter, speed, tav, adet</td></tr>
            <tr><td>2</td><td><strong>Kalaylama</strong></td><td>Drawn wire from KC</td><td>Tinned wire (e.g. 21 pieces)</td><td>tin_thickness, speed, <strong>adet</strong> (critical!)</td></tr>
            <tr><td>3</td><td><strong>&Idot;ncetel &Ccedil;ekme</strong></td><td>Tinned wire from KL</td><td>Fine wire bundles (e.g. 10&times;0.30mm)</td><td>input_number, output_diameter, output_number, tav</td></tr>
            <tr><td>4</td><td><strong>Buncher</strong></td><td>Fine wires from IC / other BN / EX</td><td>Bunched/twisted wire</td><td>dynamic inputs (+ekle), hatve, twist_direction (S/Z)</td></tr>
            <tr><td>5</td><td><strong>Extruder</strong></td><td>Bunched wire from BN / other EX</td><td>Insulated/sheathed cable</td><td>insulation_thickness, sheath_thickness, catalyst, dye</td></tr>
            <tr><td>6</td><td><strong>E-beam</strong></td><td>Extruded cable (no catalyst!)</td><td>Cross-linked cable</td><td>radiation_level, speed (set at production time)</td></tr>
        </table>

        <h4>Machine Flow Constraints</h4>
        <p>Not every machine can follow every other machine. The system enforces a directed graph:</p>

        <div class="flow">
            <span class="flow-step">Kabatel &Ccedil;ekme</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Kalaylama</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">&Idot;ncetel &Ccedil;ekme</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Buncher</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Extruder</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">E-beam</span>
        </div>

        <p>Critical loop capabilities:</p>
        <ul>
            <li><strong>Buncher &rarr; Buncher:</strong> Multi-stage bunching (bunched wire can be re-bunched)</li>
            <li><strong>Extruder &rarr; Extruder:</strong> Multi-layer extrusion (insulate first, then sheath)</li>
            <li><strong>Extruder &rarr; Buncher:</strong> Multi-core cables (insulate individual cores, then bunch them together, then sheath)</li>
        </ul>

        <pre style="background: #f5f5f5; padding: 16px; border-radius: 8px; overflow-x: auto; font-size: 13px;">
<span style="color: #666;"># Machine flow constraints (playground_session.py)</span>
MACHINE_FLOW = {
    'kabatel_cekme': ['kalaylama'],
    'kalaylama':     ['incetel_cekme', 'buncher'],
    'incetel_cekme': ['buncher', 'extruder'],
    'buncher':       ['extruder', 'buncher'],    <span style="color: #666;"># Self-loop!</span>
    'extruder':      ['ebeam', 'extruder'],      <span style="color: #666;"># Self-loop!</span>
    'ebeam':         []                          <span style="color: #666;"># Terminal</span>
}</pre>

        <h3>6.5.2 Backend Architecture &mdash; The Engine</h3>

        <p>The Playground backend is built from 8 Python files totaling ~4,700 lines:</p>

        <table>
            <tr><th>File</th><th>Lines</th><th>Purpose</th></tr>
            <tr><td><code>design_routes.py</code></td><td>1,155</td><td>API endpoints &mdash; session, steps, config, undo/redo, autosave, finalize</td></tr>
            <tr><td><code>playground_session.py</code></td><td>986</td><td>Session manager &mdash; step lifecycle, undo/redo stacks, checkpoint/restore</td></tr>
            <tr><td><code>progression_manager_v2.py</code></td><td>995</td><td>Quantity tracking &mdash; consume inputs, produce outputs, per-machine processing</td></tr>
            <tr><td><code>db_integration.py</code></td><td>446</td><td>Real machine data &mdash; reads machine tables, capability intersection</td></tr>
            <tr><td><code>form_integration.py</code></td><td>339</td><td>Form population &mdash; builds dropdown data per machine type</td></tr>
            <tr><td><code>validation_engine.py</code></td><td>465</td><td>Configuration validation &mdash; checks ranges against machine capabilities</td></tr>
            <tr><td><code>code_generator.py</code></td><td>291</td><td>Deterministic product codes &mdash; SHA256 hash + human-readable codes</td></tr>
            <tr><td><code>playground_configs.py</code></td><td>446</td><td>Pydantic schemas &mdash; typed config for each machine type</td></tr>
        </table>

        <h4>Session Management (In-Memory)</h4>

        <p>Sessions are stored in a Python dictionary (<code>_active_sessions: Dict[str, PlaygroundSession]</code>). Each session contains:</p>

        <ul>
            <li><strong>session_id:</strong> UUID v4</li>
            <li><strong>standard:</strong> EN / UL / SLN (selected at session start)</li>
            <li><strong>cross_section:</strong> e.g. &ldquo;6mm&sup2;&rdquo; (selected at session start)</li>
            <li><strong>steps:</strong> List of <code>DesignStep</code> dataclass instances</li>
            <li><strong>progression:</strong> <code>ProgressionManager</code> instance tracking all items</li>
            <li><strong>history_stack / redo_stack:</strong> <code>StateSnapshot</code> lists (max 50) for undo/redo</li>
            <li><strong>autosave:</strong> enabled by default, 30-second interval, tracks unsaved changes</li>
        </ul>

        <h4>The Progression Panel &mdash; Heart of the Design</h4>

        <p>The <code>ProgressionManager</code> maintains a list of <code>ProgressionItem</code> objects. Each item represents a physical product (wire, bunched wire, cable) at some stage of manufacturing:</p>

        <pre style="background: #f5f5f5; padding: 16px; border-radius: 8px; overflow-x: auto; font-size: 13px;">
<span style="color: #666;"># ProgressionItem fields</span>
{
    'id': 'uuid',                    <span style="color: #666;"># Unique identifier</span>
    'code': 'KC_18',                 <span style="color: #666;"># Deterministic product code</span>
    'quantity': 21,                  <span style="color: #666;"># Current available amount</span>
    'original_quantity': 21,         <span style="color: #666;"># Amount when first produced</span>
    'structure': '1.8mm',            <span style="color: #666;"># Structure formula</span>
    'specification': '1.8mm Tel',    <span style="color: #666;"># Human-readable name</span>
    'status': 'active' | 'inactive', <span style="color: #666;"># Inactive = fully consumed</span>
    'produced_by_step': 1,           <span style="color: #666;"># Which step created this</span>
    'consumed_by_steps': [2],        <span style="color: #666;"># Steps that consumed from this</span>
    'machine_type': 'kabatel_cekme', <span style="color: #666;"># Source machine</span>
    'properties': { ... }            <span style="color: #666;"># Machine-specific data</span>
}</pre>

        <p><strong>Key rules:</strong></p>
        <ul>
            <li>Session always starts with one item: <code>RAW_COPPER_8MM</code> (8mm filma&scedil;in, qty 1)</li>
            <li>When a step consumes items, their quantity decreases. At 0, status becomes <code>inactive</code>.</li>
            <li>When a step produces items, new <code>ProgressionItem</code>s are created and added.</li>
            <li>Each machine type has its own <code>process_*</code> method that handles consumption/production logic.</li>
            <li>Same-code items are combined (quantity added) unless they&rsquo;re parallel process outputs.</li>
        </ul>

        <h4>Quantity Tracking Example &mdash; 6mm&sup2; Cable</h4>

        <div class="flow">
            <span class="flow-step">8mm Filma&scedil;in (qty: 1)</span>
            <span class="flow-arrow">&rarr; KC</span>
            <span class="flow-step">1.8mm Tel (qty: 1)</span>
            <span class="flow-arrow">&rarr; KL (adet=21)</span>
            <span class="flow-step">1.8mm Kalay&inodot; (qty: 21)</span>
        </div>
        <div class="flow" style="margin-top: 8px;">
            <span class="flow-step">&darr; IC (10 consumed)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">10&times;0.30 (qty: 4)</span>
            <span class="flow-arrow">&nbsp;&nbsp;&nbsp;</span>
            <span class="flow-step">&darr; IC (11 consumed)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">11&times;0.30 (qty: 3)</span>
        </div>
        <div class="flow" style="margin-top: 8px;">
            <span class="flow-step">&darr; Buncher (4+3)</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">BN_17X030 (qty: 1)</span>
            <span class="flow-arrow">&rarr; EX</span>
            <span class="flow-step">U_17X030+INS+SHT (qty: 1)</span>
        </div>

        <div class="finding">
            <p style="margin-bottom: 0;"><strong>The critical adet parameter:</strong> At the Kalaylama step, <code>adet=21</code> is what makes the entire 6mm&sup2; cable work. Kalaylama consumes 1 input but produces 21 pieces, which are then split between two parallel &Idot;ncetel &Ccedil;ekme processes (10+11=21). This quantity tracking is the core innovation of the progression system.</p>
        </div>

        <h4>Atomic Transactions with Checkpoint/Restore</h4>

        <p>Every configuration attempt is wrapped in an atomic transaction:</p>

        <div class="flow">
            <span class="flow-step">Create checkpoint</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Apply config</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Simulate step</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Success? Keep. Fail? Restore checkpoint.</span>
        </div>

        <p>The <code>StateSnapshot</code> captures the complete session state (steps + progression items + consumption log + step counter). On failure, the session is restored to exactly its previous state.</p>

        <h3>6.5.3 API Endpoints &mdash; 30+ Endpoints</h3>

        <h4>Session Management</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/playground/start</code></td><td>Start session with standard + cross_section. Returns session_id + initial state.</td></tr>
            <tr><td><code>GET</code></td><td><code>/playground/{id}/state</code></td><td>Get full session state (steps + progression + summary).</td></tr>
        </table>

        <h4>Step Management</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/steps/add</code></td><td>Add machine step (sequential or parallel). Validates flow constraints.</td></tr>
            <tr><td><code>DELETE</code></td><td><code>/playground/{id}/steps/{step_id}</code></td><td>Remove step with full rollback of consumed items. Reports affected dependent steps.</td></tr>
        </table>

        <h4>Form Data (per machine type)</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>What It Does</th></tr>
            <tr><td><code>GET</code></td><td><code>/playground/{id}/form-data/kabatel-cekme</code></td><td>Machines, fixed input (8mm), tests for standard</td></tr>
            <tr><td><code>GET</code></td><td><code>/playground/{id}/form-data/kalaylama</code></td><td>Machines, inputs from progression (KC outputs), tests</td></tr>
            <tr><td><code>GET</code></td><td><code>/playground/{id}/form-data/incetel-cekme</code></td><td>Machines, tinned inputs with max_quantity, machine input limits</td></tr>
            <tr><td><code>GET</code></td><td><code>/playground/{id}/form-data/buncher</code></td><td>Machines, Z/T/U-coded inputs with quantities, twist directions</td></tr>
            <tr><td><code>GET</code></td><td><code>/playground/{id}/form-data/extruder</code></td><td>Machines, T/U-coded inputs, layer options (ins/sheath + catalyst/dye)</td></tr>
            <tr><td><code>GET</code></td><td><code>/playground/{id}/form-data/ebeam</code></td><td>Machines, extruder outputs <strong>without catalyst only</strong></td></tr>
        </table>

        <h4>Machine Configuration (per type)</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/configure/kabatel-cekme/{step}</code></td><td>Configure KC: output_diameter, speed, tav, adet</td></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/configure/kalaylama/{step}</code></td><td>Configure KL: input selection, tin_thickness, speed, <strong>adet</strong></td></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/configure/incetel-cekme/{step}</code></td><td>Configure IC: input, input_number, output_diameter, output_number</td></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/configure/buncher/{step}</code></td><td>Configure BN: dynamic inputs, hatve, twist_direction</td></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/configure/extruder/{step}</code></td><td>Configure EX: inputs (1+ for twin), ins/sheath layers</td></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/configure/ebeam/{step}</code></td><td>Configure EB: input selection (no catalyst)</td></tr>
            <tr><td><code>PUT</code></td><td><code>/playground/{id}/configure/{step}/edit</code></td><td>Edit already-configured step (rollback + re-apply)</td></tr>
        </table>

        <h4>Capability Intersection</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/calculate-intersection/{type}</code></td><td>Given selected machine IDs, return only values ALL can produce. Called dynamically when user checks/unchecks machines.</td></tr>
        </table>

        <h4>Undo/Redo &amp; Autosave</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/undo</code></td><td>Pop from history stack, push current to redo stack</td></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/redo</code></td><td>Pop from redo stack, push current to history stack</td></tr>
            <tr><td><code>GET</code></td><td><code>/playground/{id}/history</code></td><td>Can undo? Can redo? Stack sizes.</td></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/autosave</code></td><td>Save session state, mark as saved</td></tr>
            <tr><td><code>GET</code></td><td><code>/playground/{id}/autosave-status</code></td><td>Enabled, interval, seconds since save</td></tr>
            <tr><td><code>PUT</code></td><td><code>/playground/{id}/autosave-settings</code></td><td>Toggle enabled, change interval</td></tr>
        </table>

        <h4>Validation &amp; Finalization</h4>
        <table>
            <tr><th>Method</th><th>Path</th><th>What It Does</th></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/validate/{step}</code></td><td>Dry-run validation: checks inputs exist, quantities sufficient</td></tr>
            <tr><td><code>POST</code></td><td><code>/playground/{id}/finalize</code></td><td>Finalize design &rarr; saves to <code>cable_designs</code> + <code>design_steps</code> + <code>cable_database</code> in one transaction</td></tr>
        </table>

        <h3>6.5.4 Machine Configuration Schemas</h3>

        <p>Each machine type has a Pydantic schema defining its exact form fields in order:</p>

        <table>
            <tr><th>Machine</th><th>Schema</th><th>Fields (in order)</th></tr>
            <tr><td>Kabatel &Ccedil;ekme</td><td><code>KabatelCekmeConfig</code></td><td>alternative_machines, input_type (fixed), output_diameter, speed, tav, adet, tests</td></tr>
            <tr><td>Kalaylama</td><td><code>KalaylamaConfig</code></td><td>alternative_machines, input_item_id, tin_thickness, speed, adet, tests</td></tr>
            <tr><td>&Idot;ncetel &Ccedil;ekme</td><td><code>IncetelCekmeConfig</code></td><td>alternative_machines, input_item_id, input_number, output_diameter, speed, tav, output_number, tests</td></tr>
            <tr><td>Buncher</td><td><code>BuncherConfig</code></td><td>alternative_machines, inputs (List[BuncherInputBlock]), adet, speed, hatve, twist_direction, tests</td></tr>
            <tr><td>Extruder</td><td><code>ExtruderConfig</code></td><td>alternative_machines, inputs (1+ for twin), insulation_*, sheath_*, speed, tests. <strong>No adet</strong> (always 1).</td></tr>
            <tr><td>E-beam</td><td><code>EbeamConfig</code></td><td>alternative_machines, input_item_id, tests. Speed/radiation set at production time.</td></tr>
        </table>

        <div class="finding">
            <p style="margin-bottom: 0;"><strong>E-beam is design-only:</strong> Unlike other machines, E-beam&rsquo;s speed and radiation_level are <em>not</em> set during design. They are production-time parameters determined by the cable&rsquo;s material properties. The Playground only records <em>which</em> cable goes through E-beam and assigns tests.</p>
        </div>

        <h3>6.5.5 Capability Intersection &mdash; Multi-Machine Flexibility</h3>

        <p>When a user selects multiple alternative machines for a step, the system computes the <strong>intersection</strong> of their capability ranges. Only values that <em>all</em> selected machines can produce appear in the dropdowns.</p>

        <pre style="background: #f5f5f5; padding: 16px; border-radius: 8px; overflow-x: auto; font-size: 13px;">
<span style="color: #666;"># Machine A speed options: [5, 10, 15, 20, 25]</span>
<span style="color: #666;"># Machine B speed options: [10, 15, 20, 25, 30]</span>
<span style="color: #666;"># Intersection: [10, 15, 20, 25]</span>
<span style="color: #666;"># This means any value from the intersection can be</span>
<span style="color: #666;"># produced on ANY selected machine â†’ production flexibility</span></pre>

        <p>This is called dynamically via <code>POST /calculate-intersection/{machine_type}</code> every time the user checks or unchecks a machine checkbox in the configuration drawer.</p>

        <h3>6.5.6 Deterministic Code Generation</h3>

        <p>The <code>CableCodeGenerator</code> ensures that <strong>identical products always get the same code</strong>, critical for stock management:</p>

        <table>
            <tr><th>Product Type</th><th>Code Format</th><th>Example</th></tr>
            <tr><td>Raw material</td><td><code>RAW_XX_spec</code></td><td><code>RAW_COPPER_8MM</code></td></tr>
            <tr><td>Half product</td><td><code>HALF_MC_spec</code></td><td><code>HALF_KC_180</code> (1.8mm wire from Kabatel)</td></tr>
            <tr><td>Final cable</td><td><code>EN-6MM2-structure-I07-S08</code></td><td><code>EN-6MM2-17X030-I07-S08</code></td></tr>
        </table>

        <p>A SHA256 <code>spec_hash</code> is computed from the full specifications (product_type + machine_type + inputs + outputs + parameters) with <code>sort_keys=True</code> for determinism. If a product with the same hash already exists in <code>product_codes</code>, its existing system_code is returned. Otherwise, a new code is generated with collision-handling (sequence suffix <code>_001</code>, <code>_002</code>, etc.).</p>

        <h3>6.5.7 Special Cable Types</h3>

        <h4>Twin Cables (Extruder)</h4>
        <p>Extruder supports <strong>multiple inputs</strong> for twin/triple cables. Structure uses <code>||</code> separator: <code>(cable1 || cable2)+SHT_0.8mm</code>. Frontend detects twin count from <code>||</code> and generates Turkish names: &Idot;kiz, &Uuml;&ccedil;&uuml;z, D&ouml;rd&uuml;z, Be&scedil;iz.</p>

        <h4>Multi-Core Cables (Extruder &rarr; Buncher &rarr; Extruder)</h4>
        <p>For multi-damar (multi-core) cables, the flow loops: Extruder applies insulation to individual cores, Buncher groups the insulated cores together, then Extruder applies the outer sheath. The system detects this via <code>INS_</code> patterns in the structure formula.</p>

        <h4>E-beam Cables (No Catalyst)</h4>
        <p>E-beam cross-linking replaces chemical catalyst. The form integration <strong>completely hides</strong> cables with catalyst from the E-beam input dropdown &mdash; they are not shown at all, preventing invalid combinations.</p>

        <h3>6.5.8 Frontend &mdash; Playground Page</h3>

        <p>Main file: <code>src/pages/Teknik/CablePlayground/index.tsx</code> (947 lines) with 7 component files and 1 custom hook.</p>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>CablePlayground (index.tsx)</h4>
                <p>Main orchestrator. Session start modal (standard + cross-section selection), view mode toggle (flow/timeline/code), undo/redo/autosave controls.</p>
            </div>
            <div class="arch-box">
                <h4>FlowCanvas</h4>
                <p>Visual flow diagram with drag-drop machine placement. Shows production steps as connected nodes.</p>
            </div>
            <div class="arch-box">
                <h4>ConfigurationDrawer</h4>
                <p>~1,215 lines. The largest component. Opens as a side drawer when configuring a machine. Dynamic forms per machine type. Intersection calculation on machine checkbox change.</p>
            </div>
            <div class="arch-box">
                <h4>ProgressionPanel</h4>
                <p>Right-side panel showing all items (active/inactive) with quantities, codes, structures. Drives input selection for subsequent steps.</p>
            </div>
            <div class="arch-box">
                <h4>MachineLibrary</h4>
                <p>Draggable machine palette. 6 machine types with icons and labels.</p>
            </div>
            <div class="arch-box">
                <h4>usePlayground Hook</h4>
                <p>591 lines. All API integration. Manages session state, loading states, error handling. Bearer token auth via localStorage.</p>
            </div>
        </div>

        <h4>Session Start Flow</h4>
        <div class="flow">
            <span class="flow-step">Click &ldquo;Oturum Ba&scedil;lat&rdquo;</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Modal: select EN/UL/SLN + cross-section</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">POST /playground/start</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Canvas appears with 8mm filma&scedil;in in progression</span>
        </div>

        <h4>Machine Configuration Flow</h4>
        <div class="flow">
            <span class="flow-step">Add machine from library</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">POST /steps/add</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Click machine node on canvas</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">GET /form-data/{type}</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">ConfigurationDrawer opens</span>
        </div>
        <div class="flow" style="margin-top: 8px;">
            <span class="flow-step">Select machines &rarr; POST /calculate-intersection</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Dropdowns update dynamically</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Fill form &rarr; POST /configure/{type}/{step}</span>
            <span class="flow-arrow">&rarr;</span>
            <span class="flow-step">Progression updates</span>
        </div>

        <!-- ============================================ -->
        <!-- 6.6  CABLE DATABASE                          -->
        <!-- ============================================ -->

        <h2 id="cable-database" style="margin-top: 48px;">6.6 Kablo Veritaban&inodot; (Cable Database)</h2>

        <h3>6.6.1 What Gets Saved &mdash; The Finalization Process</h3>

        <p>When the user clicks &ldquo;Finalize&rdquo; in the Playground, the system saves three things in one database transaction:</p>

        <table>
            <tr><th>Table</th><th>What Gets Saved</th></tr>
            <tr><td><code>cable_designs</code></td><td>Design metadata: code, name, standard, cross_section, full JSON design_data, approval status, created_by</td></tr>
            <tr><td><code>design_steps</code></td><td>Each production step: step_number, machine_type, parallel_group, machine_ids, inputs/outputs/configuration/tests as JSON</td></tr>
            <tr><td><code>cable_database</code></td><td>The finalized cable record: cable_code, cable_type, cross_section, structure_formula, production_flow, half_products, raw_materials, test_requirements (all as JSON)</td></tr>
        </table>

        <h3>6.6.2 Database Schema &mdash; 4 Tables</h3>

        <h4>cable_designs (375 lines model)</h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Purpose</th></tr>
            <tr><td><code>id</code></td><td>Integer PK</td><td>Unique ID</td></tr>
            <tr><td><code>design_code</code></td><td>String(50) UNIQUE</td><td>Generated code</td></tr>
            <tr><td><code>design_name</code></td><td>String(200)</td><td>Optional name</td></tr>
            <tr><td><code>standard</code></td><td>String(50), CHECK IN (EN, UL, SLN)</td><td>Cable standard</td></tr>
            <tr><td><code>cross_section</code></td><td>String(50)</td><td>e.g. &ldquo;6mm&sup2;&rdquo;</td></tr>
            <tr><td><code>design_data</code></td><td>Text (JSON)</td><td>Complete session state</td></tr>
            <tr><td><code>is_approved</code></td><td>Boolean</td><td>Auto-approved in simplified workflow</td></tr>
            <tr><td><code>is_active</code></td><td>Boolean</td><td>Soft delete</td></tr>
            <tr><td><code>created_by / approved_by</code></td><td>Integer FK &rarr; users</td><td>User tracking</td></tr>
        </table>

        <h4>design_steps</h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Purpose</th></tr>
            <tr><td><code>id</code></td><td>Integer PK</td><td>Unique ID</td></tr>
            <tr><td><code>design_id</code></td><td>Integer FK &rarr; cable_designs (CASCADE)</td><td>Parent design</td></tr>
            <tr><td><code>step_number</code></td><td>Integer</td><td>Sequential position</td></tr>
            <tr><td><code>is_parallel / parallel_group</code></td><td>Boolean / Integer</td><td>Parallel processing support</td></tr>
            <tr><td><code>machine_type</code></td><td>String(50)</td><td>kabatel_cekme, kalaylama, etc.</td></tr>
            <tr><td><code>machine_ids</code></td><td>Text</td><td>Comma-separated alternative machine IDs</td></tr>
            <tr><td><code>configuration</code></td><td>Text (JSON)</td><td>Full machine config</td></tr>
            <tr><td><code>inputs / outputs / tests</code></td><td>Text (JSON each)</td><td>Step I/O and test assignments</td></tr>
        </table>

        <p>Unique constraint: <code>(design_id, step_number, parallel_group)</code></p>

        <h4>cable_database &mdash; The Core Record</h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Purpose</th></tr>
            <tr><td><code>id</code></td><td>Integer PK</td><td>Unique ID</td></tr>
            <tr><td><code>design_id</code></td><td>Integer FK &rarr; cable_designs</td><td>Source design</td></tr>
            <tr><td><code>cable_code</code></td><td>String(100) UNIQUE, indexed</td><td>Unique cable identifier used everywhere</td></tr>
            <tr><td><code>standard</code></td><td>String(50)</td><td>EN, UL, SLN</td></tr>
            <tr><td><code>cable_type</code></td><td>String(200)</td><td>e.g. &ldquo;EN 6mm&sup2; Klasik Kablo&rdquo;</td></tr>
            <tr><td><code>cross_section</code></td><td>String(50)</td><td>e.g. &ldquo;6mm&sup2;&rdquo;</td></tr>
            <tr><td><code>structure_formula</code></td><td>Text</td><td>Full structure notation</td></tr>
            <tr><td><code>production_flow</code></td><td>Text (JSON)</td><td>Step-by-step production sequence with configs</td></tr>
            <tr><td><code>half_products</code></td><td>Text (JSON)</td><td>All intermediate products with properties</td></tr>
            <tr><td><code>raw_materials</code></td><td>Text (JSON)</td><td>Required raw materials (A=Copper, B=Tin, C=Plastic, D=Catalyst, E=Dye)</td></tr>
            <tr><td><code>test_requirements</code></td><td>Text (JSON)</td><td>Tests assigned at each step with frequencies</td></tr>
            <tr><td><code>is_active</code></td><td>Boolean</td><td>Soft delete</td></tr>
        </table>

        <h4>product_codes &mdash; Stock Management Bridge</h4>
        <table>
            <tr><th>Column</th><th>Type</th><th>Purpose</th></tr>
            <tr><td><code>system_code</code></td><td>String(100) UNIQUE</td><td>Human-readable code (HALF_KC_180)</td></tr>
            <tr><td><code>spec_hash</code></td><td>String(256) UNIQUE</td><td>SHA256 of specifications (deterministic)</td></tr>
            <tr><td><code>product_type</code></td><td>String(50)</td><td>raw / half / final</td></tr>
            <tr><td><code>machine_type</code></td><td>String(50)</td><td>Which machine produces it</td></tr>
            <tr><td><code>display_name_tr / en</code></td><td>String(200)</td><td>Turkish/English display names</td></tr>
            <tr><td><code>used_in_designs</code></td><td>Text (JSON)</td><td>Array of cable codes using this product</td></tr>
            <tr><td><code>stock_level</code></td><td>Float</td><td>Current stock quantity</td></tr>
        </table>

        <h3>6.6.3 Cable Database API &mdash; 15+ Endpoints</h3>

        <table>
            <tr><th>Method</th><th>Path</th><th>Permission</th><th>What It Does</th></tr>
            <tr><td><code>GET</code></td><td><code>/cable-database</code></td><td>Authenticated</td><td>List cables. Filters: search, cross_section, active_only. Generates display_name with twin/core/layer detection.</td></tr>
            <tr><td><code>GET</code></td><td><code>/cable-database/{code}</code></td><td>Authenticated</td><td>Single cable by code.</td></tr>
            <tr><td><code>GET</code></td><td><code>/cable-database/{code}/full</code></td><td>Authenticated</td><td><strong>Complete raw data</strong> for material calculator. Returns half_products with ALL properties.</td></tr>
            <tr><td><code>GET</code></td><td><code>/cable-database/{code}/production-flow</code></td><td>Authenticated</td><td>Step-by-step production sequence.</td></tr>
            <tr><td><code>GET</code></td><td><code>/cable-database/{code}/half-products</code></td><td>Authenticated</td><td>All intermediate products.</td></tr>
            <tr><td><code>GET</code></td><td><code>/cable-database/{code}/requirements</code></td><td>Authenticated</td><td>Raw materials + test requirements.</td></tr>
            <tr><td><code>GET</code></td><td><code>/cable-database/{code}/parsed-structure</code></td><td>Authenticated</td><td>Structure parsed into extrusion steps for order forms.</td></tr>
            <tr><td><code>PUT</code></td><td><code>/cable-database/{code}/deactivate</code></td><td>super_admin, production_manager</td><td>Soft delete (is_active=false).</td></tr>
            <tr><td><code>DELETE</code></td><td><code>/cable-database/{code}/permanent</code></td><td>super_admin</td><td>Hard delete cable + related design. Broadcasts real-time update.</td></tr>
            <tr><td><code>GET</code></td><td><code>/products/codes</code></td><td>Authenticated</td><td>List all product codes with filters.</td></tr>
            <tr><td><code>GET</code></td><td><code>/products/{code}/usage</code></td><td>Authenticated</td><td>Which cables use this product + stock level.</td></tr>
            <tr><td><code>PUT</code></td><td><code>/products/{code}/stock</code></td><td>super_admin, production_manager, operator</td><td>Update stock level.</td></tr>
            <tr><td><code>GET</code></td><td><code>/analytics/common-products</code></td><td>Authenticated</td><td>Products used in 2+ cables (stock optimization).</td></tr>
            <tr><td><code>GET</code></td><td><code>/analytics/production-efficiency</code></td><td>Authenticated</td><td>Reuse %, efficiency score, recommendations.</td></tr>
        </table>

        <h3>6.6.4 Frontend &mdash; Cable Database Page</h3>

        <p>Single file: <code>src/pages/Teknik/CableDatabase/index.tsx</code> (691 lines). Route: <code>/teknik/kablo-veritabani</code>.</p>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>ProTable</h4>
                <p>Main data table listing all cables with display_name, cable_code, standard, cross_section, status. Client-side search.</p>
            </div>
            <div class="arch-box">
                <h4>Detail Drawer</h4>
                <p>Opens when clicking a cable. Tabs: Production Flow (Timeline visualization), Half Products (List), Requirements (raw materials + tests).</p>
            </div>
            <div class="arch-box">
                <h4>ProductionFlowViewer</h4>
                <p>Ant Design Timeline component showing each production step with machine icons, parameters, and parallel indicators.</p>
            </div>
        </div>

        <h3>6.6.5 How Cable Database Feeds the Rest of the System</h3>

        <div class="arch-grid">
            <div class="arch-box">
                <h4>&rarr; Sipari&scedil; (Order Module)</h4>
                <p>Order creation fetches cable designs from cable_database. Each order cable stores <code>cable_code</code>. The <code>/parsed-structure</code> endpoint provides extrusion step data for dynamic material selection (plastic, catalyst, dye per layer).</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; &Uuml;retim Planlama (Production Planning)</h4>
                <p>Work card generator reads <code>production_flow</code> and <code>half_products</code> to create work cards for each machine step. The <code>/full</code> endpoint provides complete data for material calculations.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Material Calculator</h4>
                <p>Reads cable_database to calculate raw material quantities (copper kg, plastic kg, tin kg, catalyst kg, dye kg) based on half_products properties (wire_count, wire_groups, bundle_diameter).</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Stok (Stock Module)</h4>
                <p>Product codes from cable_database link to stock tracking. Same half product used in multiple cables = shared stock. The <code>used_in_designs</code> array enables cross-cable stock optimization.</p>
            </div>
            <div class="arch-box">
                <h4>&rarr; Global Search</h4>
                <p>Search module indexes cable_database fields (cable_code, cable_type, cross_section, structure_formula) for system-wide search.</p>
            </div>
        </div>

        <div class="discovery">
            <p style="margin-bottom: 0;"><strong>Design principle:</strong> The Playground is a <em>production simulation engine</em>, not a drawing tool. It doesn&rsquo;t just record specifications &mdash; it executes the entire manufacturing logic step by step, tracking exact quantities, enforcing machine flow constraints, validating against real machine capabilities, and computing capability intersections. The result is a complete production blueprint stored in Cable Database that every downstream module trusts as the single source of truth. The deterministic code generation ensures identical products always get the same code, enabling stock reuse across different cable designs. The in-memory session architecture with atomic checkpoint/restore guarantees that no partial or invalid state ever reaches the database.</p>
        </div>

    </main>

</body>
</html>
